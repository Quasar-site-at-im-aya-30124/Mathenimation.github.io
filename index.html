<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maths Equation Editor</title>
    <!-- MathJax Configuration -->
    <script>
        MathJax = {
            loader: { load: ['input/asciimath', 'output/chtml'] },
            asciimath: { 
                delimiters: [['`', '`']], // Use backticks for math
                symbols: {
                    '‚àö': ['\u221A', 1], // Square root
                    'abs': ['|', 1], // Absolute value
                    'mod': ['\u0025', 1], // Modulus operator for modular arithmetic
                    '‚â°': ['\u2261', 1], // Congruence symbol
                    'log': ['\u006C\u006F\u0067', 1], // Logarithm
                    'exp': ['\u0065\u005E', 1], // Exponential
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" async></script>
    <!-- html2canvas for download -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #1c2526; /* Dark theme background */
            color: #e0e0e0; /* Light text for contrast */
        }
        h1, p, li {
            color: #e0e0e0; /* Light text for headers, paragraphs, lists */
        }
        #header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #header-row h1 {
            margin: 0;
        }
        #header-row .menu-buttons {
            display: flex;
            gap: 10px;
        }
        #header-row button {
            padding: 8px 12px;
            font-size: 16px;
            background-color: #4a4a4a; /* Dark button background */
            color: #e0e0e0; /* Light button text */
            border: 1px solid #666; /* Darker border */
            cursor: pointer;
        }
        #header-row button:hover {
            background-color: #5a5a5a; /* Slightly lighter on hover */
        }
        #input {
            width: 100%;
            height: 100px;
            font-size: 18px;
            background-color: #2e2e2e; /* Dark textarea background */
            color: #e0e0e0; /* Light text */
            border: 1px solid #4a4a4a; /* Darker border */
            padding: 10px;
            margin-top: 10px; /* Space above textarea */
            box-sizing: border-box;
        }
        #start-btn, #controls-row button, dialog button {
            margin: 10px 5px;
            padding: 10px;
            font-size: 16px;
            background-color: #4a4a4a; /* Dark button background */
            color: #e0e0e0; /* Light button text */
            border: 1px solid #666; /* Darker border */
            cursor: pointer;
        }
        #start-btn:hover, #controls-row button:hover, dialog button:hover {
            background-color: #5a5a5a; /* Slightly lighter on hover */
        }
        #output {
            font-size: 24px;
            position: relative;
            min-height: 200px;
            white-space: pre-wrap;
            overflow-wrap: break-word; /* Ensure long words wrap */
            max-width: 100%; /* Prevent overflow beyond container */
            box-sizing: border-box; /* Include padding/border in width */ 
            /* Display Background*/
            background-color: lawngreen; /* Dark green #013220background for display screen */
            color: black; /* Light text #e0e0e0 for contrast */
            border: 1px solid #4a4a4a; /* Darker border */
            padding: 10px;
            margin: 10px 0; /* Space above and below output */
            overflow-x: auto; /* Add scrollbar if content still overflows */
        }
        
        /* Override MathJax colors inside output */
        #output mjx-container,
        #output mjx-container * {
        color: black !important;
        fill: black !important;
        }

        #hand {
            position: absolute;
            font-size: 30px;
            transform: rotate(45deg);
            transition: left 0.1s ease, top 0.1s ease, transform 0.5s ease, opacity 0.5s ease 0.5s;
            animation: float 1.5s ease-in-out infinite;
            opacity: 1;
            color: #e0e0e0; /* Light hand emoji for visibility */
        }
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(45deg); }
            50% { transform: translateY(-5px) rotate(45deg); }
        }
        #output.finished #hand {
            animation: none;
            transform: rotate(120deg) translate(50px, 50px);
            opacity: 0;
        }
        #cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: #e0e0e0; /* Light  cursor for contrast */
            vertical-align: middle;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        dialog {
            width: 70vw;
            height: 70vh;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
            background-color: #2e2e2e; /* Dark dialog background */
            color: black; /* Light text: #e0e0e0 */
            border: 1px solid #4a4a4a; /* Darker border */
        }
        dialog button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #4a4a4a; /* Darker border for table */
            padding: 8px;
            text-align: left;
            color: #e0e0e0; /* Light text */
        }
        th {
            background-color: #3a3a3a; /* Slightly lighter for headers */
        }
        #controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        #controls-row-left, #controls-row-right {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls-row button, #controls-row select, #controls-row input[type="range"] {
            margin-left: 5px;
            background-color: #4a4a4a; /* Dark select/slider background */
            color: #e0e0e0; /* Light text */
            border: 1px solid #666; /* Darker border */
        }
        #controls-row select {
            padding: 8px;
        }
        #controls-row select option {
            background-color: #2e2e2e; /* Dark option background */
            color: #e0e0e0; /* Light text */
        }
        #speed-slider {
            width: 100px; /* Adjust slider width */
            vertical-align: middle;
        }
        #controls {
            margin-top: 10px; /* Space above controls */
        }
        #symbols-table td {
            text-align: center;
            cursor: pointer;
            padding: 10px;
        }
        #symbols-table td:hover {
            background-color: #5a5a5a; /* Hover effect for symbols */
        }
    </style>
</head>
<body>
    <div id="header-row">
        <h1>Mathenimation</h1>
        <div class="menu-buttons">
            <button onclick="showDialog('examples')">Examples</button>
            <button onclick="showDialog('history')">History</button>
            <button onclick="showDialog('help')">Help</button>
            <button onclick="showDialog('symbols')">Symbols</button>
        </div>
    </div>
    <div id="controls-row">
        <div id="controls-row-left">
            <button id="play-pause-btn" onclick="playPauseAnimation()">‚ñ∂Ô∏è</button>
            <button onclick="stopAnimation()">‚èπÔ∏è</button>
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div id="controls-row-right">
            <button onclick="undo()">‚Ü∫</button>
            <button onclick="redo()">‚Üª</button>
            <button onclick="clearOutput()">‚Ü©</button>
            <select id="download-format">
                <optgroup label="--Image--">
                    <option value="png">Save as PNG</option>
                    <option value="jpg">Save as JPG</option>
                    <option value="webp">Save as WebP</option>
                    <option value="bmp">Save as BMP</option>
                    <option value="tiff">Save as TIFF</option>
                    <option value="gif">Save as GIF</option>
                    <option value="avif">Save as AVIF</option>
                    <option value="apng">Save as APNG</option>
                </optgroup>
                <optgroup label="--Resolutions--">
                    <option value="426x240">240p (426x240)</option>
                    <option value="640x360">360p (640x360)</option>
                    <option value="854x480">480p (854x480)</option>
                    <option value="1280x720">720p (1280x720 - HD)</option>
                    <option value="1920x1080">1080p (1920x1080 - FHD)</option>
                    <option value="2560x1440">1440p (2560x1440 - 2K/QHD)</option>
                    <option value="3840x2160">2160p (3840x2160 - 4K/UHD)</option>
                </optgroup>
            </select>
            <button onclick="downloadOutput()">üì•</button>
        </div>
    </div>
    <div id="output"></div>
    <div id="controls">
        <textarea id="input" placeholder="e.g., Modulus or Absolute Value Expression: |a| + |b| = |a + b|"></textarea>
        <div style="text-align: right; margin: 10px 0;">
            <button id="start-btn" onclick="startAnimation()">Start Animation</button>
        </div>
    </div>
    <canvas id="captureCanvas" style="display: none;"></canvas>

    <dialog id="examplesDialog">
        <h2>Examples</h2>
        <ul>
            <li>Monomial: 3x^2</li>
            <li>Binomial: x + 2y</li>
            <li>Trinomial: x^2 + 2x + 1</li>
            <li>Polynomial: x^3 + 2x^2 - x + 5</li>
            <li>Rational Expression: (x + 1)/(x - 2)</li>
            <li>Irrational Expression: ‚àö(x + 2)</li>
            <li>Radical Expression: root(3)(x^2 + 1)</li>
            <li>Square Root Expression: sqrt(x + 1) or ‚àö(x + 1)</li>
            <li>Exponential Expression: exp(x) or 2^x</li>
            <li>Logarithmic Expression: log(x) or log_2(x)</li>
            <li>Modulus (Absolute Value) Expression: |a| + |b| = |a + b|</li>
            <li>Modular Expression: x mod y = r ‚Üî x ‚â° r (mod y)</li>
            <li>Fraction: a/b</li>
            <li>Integral: int_0^1 x dx</li>
            <li>Union: A union B</li>
            <li>Matrix: [1,2;3,4]</li>
            <li>Limit: lim_(x->0) sin x / x</li>
            <li>Derivative: (d/dx) x^2</li>
            <li>Sum: sum_(k=1)^n k</li>
            <li>Product: prod_(k=1)^n k</li>
            <li>Vector: vec(a) = <<1,2,3>></li>
            <li>Binomial Coefficient: C(n,k) or binom(n)(k)</li>
            <li>Trigonometric Expression: sin x + cos y</li>
            <li>Inverse Trigonometric: arcsin(x)</li>
            <li>Trigonometric Identity: sin^2 x + cos^2 x = 1</li>
            <li>Compound Angle: sin(a + b) = sin a cos b + cos a sin b</li>
            <li>Multiple Angle: cos 2x = cos^2 x - sin^2 x</li>
            <li>Differential Expression: (d/dx) sin x = cos x</li>
            <li>Integral Expression: int_0^infty e^{-x} dx = 1</li>
            <li>Limit Expression: lim_(x->0) (sin x)/x = 1</li>
            <li>Series Expression: sum_(n=1)^infty 1/n^2 = pi^2/6</li>
            <li>Mean: bar x = (sum x_i)/n</li>
            <li>Variance: sigma^2 = (sum (x_i - bar x)^2)/n</li>
            <li>Probability: P(A union B) = P(A) + P(B) - P(A intersect B)</li>
            <li>Combinations: C(n,r) = (n!)/(r!(n-r)!)</li>
            <li>Permutations: P(n,r) = (n!)/(n-r)!</li>
            <li>Vector Expression: r = a i^ + b j^ + c k^</li>
            <li>Dot Product: (vec A dot B)</li>
            <li>Cross Product: (vec A cross B)</li>
            <li>Matrix Expression: A = [1,2,3;4,5,6]</li>
            <li>Determinant: det(A) or (det(A))</li>
            <li>Inverse Matrix: A^(-1)</li>
            <li>Complex Number Expression: z = a + b i</li>
            <li>Set Expression: A = {1,2,3}</li>
            <li>Membership: (x in A) or (x belong to A)</li>
            <li>Logical Expression: p ^^ q</li>
            <li>Quantified Expression: (for all) x in R, x^2 (greater than or equal) 0</li>
            <li>Parametric Expression: x = r cos theta, y = r sin theta</li>
            <li>Polar Expression: r = theta</li>
            <li>Tensor Expression: T_(i j)</li>
            <li>Functional Analysis Expression: ||f|| = sqrt(int |f(x)|^2 dx)</li>
            <li>Topology Expression: open set U</li>
            <li>Algebraic Structure Expression: group G</li>
        </ul>
        <button onclick="closeDialog('examples')">Close ‚ùå</button>
    </dialog>

    <dialog id="historyDialog">
        <h2>History</h2>
        <table>
            <thead>
                <tr>
                    <th>Title</th>
                    <th>Description</th>
                    <th>Date</th>
                    <th>Time</th>
                </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
        <button onclick="closeDialog('history')">Close ‚ùå</button>
    </dialog>

    <dialog id="helpDialog">
        <h2>Help</h2>
        <p>Here are some tips for using AsciiMath syntax to achieve textbook-style mathematical representations:</p>
        <ul>
            <li>For exponents/superscripts, use ^: e.g., x^2 renders as x¬≤.</li>
            <li>For subscripts, use _: e.g., x_1 renders as x‚ÇÅ.</li>
            <li>For fractions, use /: e.g., a/b or (x + 1)/(x - 2) renders as a over b.</li>
            <li>For square roots, use sqrt or ‚àö: e.g., sqrt(x + 1) or ‚àö(x + 1) renders as ‚àö(x + 1).</li>
            <li>For nth roots, use root(n): e.g., root(3)(x) renders as cube root of x.</li>
            <li>For logarithms, use log or log_b: e.g., log(x) or log_2(x).</li>
            <li>For exponentials, use exp or ^: e.g., exp(x) or 2^x.</li>
            <li>For modulus (absolute value), use abs or | |: e.g., abs(x) or |x| renders as |x|.</li>
            <li>For modular arithmetic, use mod or ‚â°: e.g., x mod y = r or x ‚â° r (mod y).</li>
            <li>For integrals, use int: e.g., int_a^b f(x) dx.</li>
            <li>For limits, use lim: e.g., lim_(x->a) f(x).</li>
            <li>For sums/products, use sum/prod: e.g., sum_(i=1)^n i.</li>
            <li>For matrices, use [ ; ]: e.g., [1,2;3,4] renders as a 2x2 matrix.</li>
            <li>For trigonometric functions, use sin, cos, tan, etc.: e.g., sin x.</li>
            <li>For inverse trigonometric, use arcsin, arccos, etc.: e.g., arcsin x.</li>
            <li>For hyperbolic functions, use sinh, cosh, etc.: e.g., sinh x.</li>
            <li>For derivatives, use (d/dx): e.g., (d/dx) x^2 = 2x.</li>
            <li>For integrals, use int: e.g., int x dx = x^2/2.</li>
            <li>For limits, use lim: e.g., lim_(x->infty) 1/x = 0.</li>
            <li>For series/sums, use sum: e.g., sum_(n=0)^infty x^n / n! = e^x.</li>
            <li>For mean, use bar or overline: e.g., bar x.</li>
            <li>For variance, use sigma^2: e.g., sigma^2 = (sum (x_i - bar x)^2)/n.</li>
            <li>For probability, use P(): e.g., P(A).</li>
            <li>For combinations, use C(n,r): e.g., C(n,r) = n! / (r!(n-r)!).</li>
            <li>For permutations, use P(n,r): e.g., P(n,r) = n! / (n-r)!.</li>
            <li>For vectors, use vec: e.g., vec a = a i^ + b j^ + c k^ renders with hats on i, j, k.</li>
            <li>For dot product, use dot: e.g., (vec A dot B) renders as \vec A ‚Ä¢ \vec B.</li>
            <li>For cross product, use cross: e.g., (vec A cross B) renders as \vec A √ó \vec B.</li>
            <li>For determinant, use det: e.g., det(A) or (det(A)) for |A|.</li>
            <li>For inverse matrix, use ^(-1): e.g., A^(-1).</li>
            <li>For complex numbers, use i: e.g., z = a + b i.</li>
            <li>For sets, use {}, in, union, intersect: e.g., A union B.</li>
            <li>For membership, use in or belong to: e.g., (x in A) or (x belong to A) renders as x ‚àà A; (x not in A) or (x does not belong to A) renders as x ‚àâ A. Without (), treated as text.</li>
            <li>For logical expressions, use ^^, vv, not, ->: e.g., p ^^ q.</li>
            <li>For quantified expressions, use for all: e.g., (for all) x in R renders as ‚àÄx ‚àà R. Without (), treated as text.</li>
            <li>For inequalities, use (greater than or equal), etc.: e.g., (greater than or equal) renders as ‚â•, (less than or equal) as ‚â§, (not equal) as ‚â†. Without (), treated as text.</li>
            <li>For parametric equations, group with commas: e.g., x = t^2, y = t^3.</li>
            <li>For polar coordinates, use r, theta: e.g., r = 1 - sin theta.</li>
            <li>For tensors, use subscripts: e.g., T_(i j k).</li>
            <li>For norms in functional analysis, use || ||: e.g., ||f||.</li>
            <li>For topology, describe in text with math: e.g., open set U.</li>
            <li>For algebraic structures, describe in text with math: e.g., group (G, *).</li>
            <li>Group with parentheses for complex expressions: e.g., (a + b)^2.</li>
            <li>Mix text and math: e.g., Modulus (Absolute Value) Expression: |a| + |b| = |a + b|.</li>
            <li>Math expressions are auto-detected; backticks are optional.</li>
        </ul>
        <button onclick="closeDialog('help')">Close ‚ùå</button>
    </dialog>

    <dialog id="symbolsDialog">
        <h2>Mathematical Symbols</h2>
        <p>Click a symbol to copy its AsciiMath code or character to the clipboard.</p>
        <table id="symbols-table">
            <tr><th>Symbol</th><th>AsciiMath Code</th><th>Description</th></tr>
            <tr><td>‚àà</td><td>in</td><td>Element of</td></tr>
            <tr><td>‚àÄ</td><td>forall</td><td>For all</td></tr>
            <tr><td>‚â•</td><td>>=</td><td>Greater than or equal to</td></tr>
            <tr><td>‚â§</td><td><=</td><td>Less than or equal to</td></tr>
            <tr><td>‚â†</td><td>!=</td><td>Not equal to</td></tr>
            <tr><td>‚àÇ</td><td>partial</td><td>Partial derivative</td></tr>
            <tr><td>‚àÉ</td><td>exists</td><td>There exists</td></tr>
            <tr><td>‚àá</td><td>grad</td><td>Gradient (nabla)</td></tr>
            <tr><td>‚àã</td><td>ni</td><td>Contains as member</td></tr>
            <tr><td>‚àè</td><td>prod</td><td>Product</td></tr>
            <tr><td>‚àô</td><td>cdot</td><td>Dot product</td></tr>
            <tr><td>‚àù</td><td>prop</td><td>Proportional to</td></tr>
            <tr><td>‚àû</td><td>infty</td><td>Infinity</td></tr>
            <tr><td>‚à™</td><td>union</td><td>Union</td></tr>
            <tr><td>‚à©</td><td>intersect</td><td>Intersection</td></tr>
            <tr><td>‚à®</td><td>vv</td><td>Logical OR</td></tr>
            <tr><td>‚àß</td><td>^^</td><td>Logical AND</td></tr>
            <tr><td>‚à†</td><td>angle</td><td>Angle</td></tr>
            <tr><td>‚à•</td><td>||</td><td>Parallel</td></tr>
            <tr><td>‚à´</td><td>int</td><td>Integral</td></tr>
            <tr><td>‚à¨</td><td>iint</td><td>Double integral</td></tr>
            <tr><td>‚àÆ</td><td>oint</td><td>Contour integral</td></tr>
            <tr><td>‚à¥</td><td>therefore</td><td>Therefore</td></tr>
            <tr><td>‚àµ</td><td>because</td><td>Because</td></tr>
            <tr><td>‚â™</td><td><<</td><td>Much less than</td></tr>
            <tr><td>‚â´</td><td>>></td><td>Much greater than</td></tr>
            <tr><td>‚äÇ</td><td>subset</td><td>Subset</td></tr>
            <tr><td>‚äÉ</td><td>supset</td><td>Superset</td></tr>
            <tr><td>‚äÜ</td><td>subseteq</td><td>Subset or equal to</td></tr>
            <tr><td>‚äá</td><td>supseteq</td><td>Superset or equal to</td></tr>
            <tr><td>‚äô</td><td>odot</td><td>Circle dot</td></tr>
            <tr><td>‚ä•</td><td>perp</td><td>Perpendicular</td></tr>
            <tr><td>¬π</td><td>^1</td><td>Superscript 1</td></tr>
            <tr><td>¬≤</td><td>^2</td><td>Superscript 2</td></tr>
            <tr><td>¬≥</td><td>^3</td><td>Superscript 3</td></tr>
            <tr><td>‚Å¥</td><td>^4</td><td>Superscript 4</td></tr>
            <tr><td>‚ÇÅ</td><td>_1</td><td>Subscript 1</td></tr>
            <tr><td>‚ÇÇ</td><td>_2</td><td>Subscript 2</td></tr>
            <tr><td>‚ÇÉ</td><td>_3</td><td>Subscript 3</td></tr>
            <tr><td>‚ÇÑ</td><td>_4</td><td>Subscript 4</td></tr>
            <tr><td>‚Åø</td><td>^n</td><td>Superscript n</td></tr>
            <tr><td>¬Ω</td><td>1/2</td><td>Fraction one-half</td></tr>
            <tr><td>‚Öì</td><td>1/3</td><td>Fraction one-third</td></tr>
            <tr><td>‚Öî</td><td>2/3</td><td>Fraction two-thirds</td></tr>
            <tr><td>¬º</td><td>1/4</td><td>Fraction one-quarter</td></tr>
            <tr><td>¬æ</td><td>3/4</td><td>Fraction three-quarters</td></tr>
            <tr><td>‚Öú</td><td>3/8</td><td>Fraction three-eighths</td></tr>
            <tr><td>‚Öù</td><td>5/8</td><td>Fraction five-eighths</td></tr>
            <tr><td>‚Öû</td><td>7/8</td><td>Fraction seven-eighths</td></tr>
            <tr><td>¬±</td><td>+-</td><td>Plus-minus</td></tr>
            <tr><td>Ôπô</td><td>(</td><td>Left parenthesis</td></tr>
            <tr><td>Ôπõ</td><td>{</td><td>Left brace</td></tr>
            <tr><td>Ôπú</td><td>}</td><td>Right brace</td></tr>
            <tr><td>Ôπû</td><td>)</td><td>Right parenthesis</td></tr>
            <tr><td>Ôπ§</td><td><</td><td>Less than</td></tr>
            <tr><td>Ôπ°</td><td>*</td><td>Asterisk (multiplication)</td></tr>
            <tr><td>Ôπ¢</td><td>+</td><td>Plus</td></tr>
            <tr><td>Ôπ¶</td><td>=</td><td>Equals</td></tr>
            <tr><td>Ôπ†</td><td>&</td><td>Ampersand (logical AND)</td></tr>
            <tr><td>Ôπü</td><td>#</td><td>Number sign</td></tr>
        </table>
        <button onclick="closeDialog('symbols')">Close ‚ùå</button>
    </dialog>

    <script>
        let entries = []; // Array of input texts
        let currentOutput = ''; // Joined with <br>
        let undoStack = [];
        let redoStack = [];
        let history = JSON.parse(localStorage.getItem('mathHistory')) || [];
        let isAnimating = false;
        let isPaused = false;
        let animationController = null;

        function processMathContent(str) {
            // Replace matrix semicolons
            str = str.replace(/\[([^\[]*?)\]/g, function(match, p1) {
                return '[[' + p1.replace(/;\s*/g, '],[') + ']]';
            });

            // Replace C(n, r) to binom(n)(r)
            str = str.replace(/C\(([\w+]+),\s*([\w+]+)\)/g, 'binom($1)($2)');

            // Replace P(n, r) to ^n P_r
            str = str.replace(/P\(([\w+]+),\s*([\w+]+)\)/g, '^$1 P_$2');

            // Replace (det(A)) to |A|
            str = str.replace(/\(\s*det\((.+?)\)\s*\)/g, '|$1|');

            // Replace cross to xx
            str = str.replace(/cross/g, 'xx');

            // Replace i^ to hat i, j^ to hat j, k^ to hat k
            str = str.replace(/i\^/g, 'hat i');
            str = str.replace(/j\^/g, 'hat j');
            str = str.replace(/k\^/g, 'hat k');

            // Handle phrases in parentheses
            if (str.startsWith('(') && str.endsWith(')')) {
                let inner = str.slice(1, -1).trim();
                const exactReplacements = {
                    'greater than or equal': '>=',
                    'less than or equal': '<=',
                    'not equal': '!=',
                };
                if (exactReplacements[inner]) {
                    str = exactReplacements[inner];
                } else {
                    // Replace patterns inside
                    inner = inner.replace(/for all/g, 'forall');
                    inner = inner.replace(/belong to/g, 'in');
                    inner = inner.replace(/does not belong to/g, 'notin');
                    inner = inner.replace(/greater than or equal/g, '>=');
                    inner = inner.replace(/less than or equal/g, '<=');
                    inner = inner.replace(/not equal/g, '!=');
                    str = inner; // Remove outer parentheses for symbols/expressions
                }
            }

            return str;
        }

        function detectMathExpressions(text) {
            const segments = [];
            let i = 0;
            const n = text.length;
            let current = '';
            let mode = 'text';
            let parenDepth = 0;
            let absDepth = 0;
            let bracketDepth = 0;

            // Keywords that should be treated as text even if they contain parentheses
            const textPhrases = [
                'Modulus (Absolute Value) Expression',
                'Absolute Value'
            ];

            const isMathStart = (char, nextChar, text, index) => {
                for (let phrase of textPhrases) {
                    if (index <= text.length - phrase.length && text.slice(index, index + phrase.length).startsWith(phrase)) {
                        return false;
                    }
                }
                if (/\d|[a-zA-Z]/i.test(char)) return true;
                if (char === '‚àö' && index + 1 < n && text.charAt(index + 1) === '(') return true;
                if (char === '(' && index + 1 < n && (/\d|[a-zA-Z]|‚àö/.test(text.charAt(index + 1)))) return true;
                if (char === '|' && index + 1 < n && (/\d|[a-zA-Z]|\(/.test(text.charAt(index + 1)))) return true;
                if (char === '‚â°') return true;
                if (char === '[' && index + 1 < n && /\d/.test(text.charAt(index + 1))) return true;
                return false;
            };
            const isMathCont = (char) => /\d|[a-zA-Z]|\^|_|\/|\(|\)|\+|\-|=|\.| |‚àí|‚àö|\||‚â°|>|<|,|:|;|\[|\]/i.test(char);
            const isLikelyMath = (s) => {
                if (s.length < 2) return false;
                const cleaned = s.replace(/ /g, '');
                if (/^\d+$/.test(cleaned) || /^[a-zA-Z]+$/.test(cleaned)) return false;
                if (s.match(/\b(sin|cos|tan|sec|csc|cot|sinh|cosh|tanh|arcsin|arccos|arctan|arcsec|arccsc|arccot|arsinh|arcosh|artanh|diff|d\/dx|int|lim|sum|prod|bar|sigma|P|binom|perm|vec|dot|xx|det|inv|i|in|forall|exists|union|intersect|^^|vv|not|->|tensor|norm|open|group)\b/i)) return true;
                if (s.includes('^') || s.includes('_') || s.includes('/') || s.includes('*') ||
                    s.includes('‚â°') || s.includes('|') ||
                    (/\d/.test(cleaned) && /[a-zA-Z]/.test(cleaned)) ||
                    cleaned.split('+').length > 1 || cleaned.split('-').length > 1 || cleaned.split('‚àí').length > 1 ||
                    s.includes('sqrt') || s.includes('‚àö') || s.includes('log') || s.includes('exp') ||
                    s.includes('abs') || s.includes('root') || s.includes('int') || s.includes('lim') ||
                    s.includes('sum') || s.includes('mod') || s.match(/\(.*\)/) || s.match(/\|.*\|/) || s.match(/\[.*\]/)) {
                    return true;
                }
                return false;
            };

            while (i < n) {
                const char = text.charAt(i);
                const nextChar = i + 1 < n ? text.charAt(i + 1) : '';

                // Check for text phrases
                let matchedPhrase = null;
                for (let phrase of textPhrases) {
                    if (text.slice(i, i + phrase.length).startsWith(phrase)) {
                        matchedPhrase = phrase;
                        break;
                    }
                }

                if (matchedPhrase && mode === 'text') {
                    segments.push({type: 'text', content: matchedPhrase});
                    current = '';
                    i += matchedPhrase.length;
                    continue;
                }

                if (mode === 'text') {
                    if (isMathStart(char, nextChar, text, i)) {
                        mode = 'math';
                        if (current) {
                            segments.push({type: 'text', content: current});
                            current = '';
                        }
                        if (char === '(') parenDepth++;
                        else if (char === '|') {
                            absDepth++;
                            current += char;
                            i++;
                            continue;
                        } else if (char === '[') bracketDepth++;
                        current += char;
                        i++;
                    } else {
                        current += char;
                        i++;
                    }
                } else {
                    if (char === '(') parenDepth++;
                    else if (char === ')') parenDepth--;
                    else if (char === '|' && absDepth > 0) {
                        absDepth--;
                    } else if (char === '[') bracketDepth++;
                    else if (char === ']') bracketDepth--;
                    current += char;
                    i++;
                    if (parenDepth < 0 || absDepth < 0 || bracketDepth < 0) {
                        // Invalid, treat as text
                        segments.push({type: 'text', content: current});
                        current = '';
                        mode = 'text';
                        parenDepth = 0;
                        absDepth = 0;
                        bracketDepth = 0;
                    } else if (!isMathCont(char) && parenDepth === 0 && absDepth === 0 && bracketDepth === 0) {
                        if (isLikelyMath(current)) {
                            current = processMathContent(current);
                            segments.push({type: 'math', content: current});
                        } else {
                            segments.push({type: 'text', content: current});
                        }
                        current = '';
                        mode = 'text';
                    }
                }
            }

            if (current) {
                if (mode === 'math' && isLikelyMath(current)) {
                    current = processMathContent(current);
                    segments.push({type: 'math', content: current});
                } else {
                    segments.push({type: 'text', content: current});
                }
            }

            return segments;
        }

        async function startAnimation() {
            if (isAnimating) return; // Prevent starting new animation if one is running
            isAnimating = true;
            isPaused = false;
            animationController = { cancelled: false };
            const inputText = document.getElementById('input').value;
            if (!inputText) {
                isAnimating = false;
                return;
            }
            const segments = detectMathExpressions(inputText);
            const output = document.getElementById('output');
            const startBtn = document.getElementById('start-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            startBtn.disabled = true;
            playPauseBtn.textContent = '‚è∏Ô∏è';
            output.classList.remove('finished');

            // Initialize with previous output
            output.innerHTML = currentOutput;

            // Create hand element
            const hand = document.createElement('span');
            hand.id = 'hand';
            hand.textContent = '‚úçÔ∏è';
            hand.style.opacity = '1';

            let currentText = currentOutput ? currentOutput + '<br>' : '';
            const baseCharDelay = 50; // Base ms per character
            const baseWordDelay = 200; // Base ms extra after word
            const speedSlider = document.getElementById('speed-slider');
            const speed = parseFloat(speedSlider.value);
            const charDelay = baseCharDelay / speed; // Faster speed reduces delay
            const wordDelay = baseWordDelay / speed;

            for (let segment of segments) {
                if (animationController.cancelled) break;
                if (segment.type === 'text') {
                    const parts = segment.content.split(/(\s+)/).filter(part => part !== '');
                    for (let part of parts) {
                        if (animationController.cancelled) break;
                        for (let char of part) {
                            if (isPaused || animationController.cancelled) {
                                while (isPaused && !animationController.cancelled) {
                                    await delay(100);
                                }
                                if (animationController.cancelled) break;
                            }
                            currentText += char;
                            output.innerHTML = currentText + '<span id="cursor"></span>';
                            output.appendChild(hand);
                            await typesetMathJax();
                            updateHandPosition(hand);
                            await delay(charDelay);
                        }
                        await delay(wordDelay);
                    }
                } else { // math
                    if (animationController.cancelled) break;
                    const mathStart = currentText.length;
                    let mathBuffer = '';
                    const parts = segment.content.split(/(\s+)/).filter(part => part !== '');
                    for (let part of parts) {
                        if (animationController.cancelled) break;
                        for (let char of part) {
                            if (isPaused || animationController.cancelled) {
                                while (isPaused && !animationController.cancelled) {
                                    await delay(100);
                                }
                                if (animationController.cancelled) break;
                            }
                            mathBuffer += char;
                            currentText += char;
                            output.innerHTML = currentText + '<span id="cursor"></span>';
                            output.appendChild(hand);
                            await typesetMathJax();
                            updateHandPosition(hand);
                            await delay(charDelay);
                        }
                        await delay(wordDelay);
                    }
                    if (animationController.cancelled) break;
                    // Convert to math
                    currentText = currentText.slice(0, mathStart) + '`' + mathBuffer + '`' + currentText.slice(mathStart + mathBuffer.length);
                    output.innerHTML = currentText + '<span id="cursor"></span>';
                    await typesetMathJax();
                    updateHandPosition(hand);
                    await delay(200); // Pause after conversion
                }
            }

            if (!animationController.cancelled) {
                // Animation complete
                output.innerHTML = currentText; // Remove cursor
                await typesetMathJax();
                output.appendChild(hand);
                updateHandPosition(hand);
                output.classList.add('finished');
                await delay(1000); // Wait for hand exit animation
                hand.remove();

                entries.push(inputText);
                undoStack.push([...entries]);
                redoStack = [];
                history.push({
                    title: `Input ${history.length + 1}`,
                    description: inputText,
                    date: new Date().toLocaleDateString(),
                    time: new Date().toLocaleTimeString()
                });
                localStorage.setItem('mathHistory', JSON.stringify(history));
                currentOutput = entries.join('<br>');
            }

            startBtn.disabled = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            isAnimating = false;
            animationController = null;
        }

        function playPauseAnimation() {
            if (!isAnimating) {
                startAnimation(); // Start animation if not running
            } else {
                isPaused = !isPaused;
                const playPauseBtn = document.getElementById('play-pause-btn');
                playPauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
            }
        }

        function stopAnimation() {
            if (!isAnimating) return;
            animationController.cancelled = true;
            isPaused = false;
            isAnimating = false;
            const output = document.getElementById('output');
            const startBtn = document.getElementById('start-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            output.innerHTML = currentOutput; // Restore last completed output
            output.classList.remove('finished');
            const hand = document.querySelector('#hand');
            if (hand) hand.remove();
            startBtn.disabled = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            typesetMathJax();
        }

        function undo() {
            if (undoStack.length) {
                redoStack.push([...entries]);
                entries = undoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function redo() {
            if (redoStack.length) {
                undoStack.push([...entries]);
                entries = redoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function clearOutput() {
            entries = [];
            undoStack = [];
            redoStack = [];
            currentOutput = '';
            document.getElementById('output').innerHTML = '';
        }

        async function downloadOutput() {
            const selected = document.getElementById('download-format').value;
            const output = document.getElementById('output');

            // Resolution mapping
            const resolutions = {
                '426x240': { width: 426, height: 240 },
                '640x360': { width: 640, height: 360 },
                '854x480': { width: 854, height: 480 },
                '1280x720': { width: 1280, height: 720 },
                '1920x1080': { width: 1920, height: 1080 },
                '2560x1440': { width: 2560, height: 1440 },
                '3840x2160': { width: 3840, height: 2160 }
            };

            // Default to original size if format is selected
            let targetWidth = output.offsetWidth;
            let targetHeight = output.offsetHeight;
            let format = selected;
            let extension = selected;

            // Check if selected value is a resolution
            if (resolutions[selected]) {
                targetWidth = resolutions[selected].width;
                targetHeight = resolutions[selected].height;
                format = 'png'; // Default format if resolution is selected
                extension = 'png';
            }

            // Map format to MIME type
            const mimeTypes = {
                'png': 'image/png',
                'jpg': 'image/jpeg',
                'webp': 'image/webp',
                'bmp': 'image/bmp',
                'tiff': 'image/tiff',
                'gif': 'image/gif',
                'avif': 'image/avif',
                'apng': 'image/apng'
            };

            try {
                // Render canvas with html2canvas
                const canvas = await html2canvas(output, {
                    width: output.offsetWidth,
                    height: output.offsetHeight,
                    scale: 1 // Capture at native resolution
                });

                // Create a new canvas for resizing
                const resizedCanvas = document.createElement('canvas');
                resizedCanvas.width = targetWidth;
                resizedCanvas.height = targetHeight;
                const ctx = resizedCanvas.getContext('2d');

                // Calculate scaling to maintain aspect ratio
                const aspectRatio = canvas.width / canvas.height;
                let drawWidth = targetWidth;
                let drawHeight = targetHeight;
                if (targetWidth / targetHeight > aspectRatio) {
                    drawWidth = targetHeight * aspectRatio;
                } else {
                    drawHeight = targetWidth / aspectRatio;
                }

                // Center the image
                const offsetX = (targetWidth - drawWidth) / 2;
                const offsetY = (targetHeight - drawHeight) / 2;
                ctx.fillStyle = '#013220'; // Match output background
                ctx.fillRect(0, 0, targetWidth, targetHeight);
                ctx.drawImage(canvas, offsetX, offsetY, drawWidth, drawHeight);

                // Handle different formats
                let dataUrl;
                if (['png', 'jpg', 'webp'].includes(format)) {
                    dataUrl = resizedCanvas.toDataURL(mimeTypes[format], format === 'jpg' ? 0.9 : 1.0);
                } else if (format === 'bmp') {
                    // BMP generation (simplified)
                    dataUrl = resizedCanvas.toDataURL('image/png'); // Fallback to PNG
                    extension = 'bmp';
                    console.warn('BMP format is not natively supported; saving as PNG with .bmp extension.');
                } else {
                    // GIF, TIFF, AVIF, APNG fallback to PNG
                    dataUrl = resizedCanvas.toDataURL('image/png');
                    console.warn(`${format.toUpperCase()} format is not supported; saving as PNG.`);
                }

                // Trigger download
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `math_output.${extension}`;
                a.click();
            } catch (err) {
                console.error('Download error:', err);
                alert('Failed to download image. Please try again.');
            }
        }

        function showDialog(id) {
            const dialog = document.getElementById(id + 'Dialog');
            dialog.showModal();
            if (id === 'history') {
                populateHistory();
            } else if (id === 'symbols') {
                setupSymbolTable();
            }
        }

        function closeDialog(id) {
            document.getElementById(id + 'Dialog').close();
        }

        function populateHistory() {
            const tbody = document.getElementById('historyBody');
            tbody.innerHTML = '';
            history.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${item.title}</td>
                    <td>${item.description}</td>
                    <td>${item.date}</td>
                    <td>${item.time}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function setupSymbolTable() {
            const table = document.getElementById('symbols-table');
            const rows = table.getElementsByTagName('tr');
            for (let i = 1; i < rows.length; i++) { // Skip header row
                const cells = rows[i].getElementsByTagName('td');
                cells[0].onclick = () => copyToClipboard(cells[0].textContent, 'Symbol');
                cells[1].onclick = () => copyToClipboard(cells[1].textContent, 'AsciiMath code');
            }
        }

        function copyToClipboard(text, type) {
            navigator.clipboard.writeText(text).then(() => {
                alert(`${type} "${text}" copied to clipboard!`);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        async function typesetMathJax() {
            try {
                await MathJax.typesetPromise([document.getElementById('output')]);
            } catch (err) {
                console.error('MathJax typesetting error:', err);
            }
        }

        function updateHandPosition(hand) {
            const cursor = document.getElementById('cursor');
            const output = document.getElementById('output');
            const outputRect = output.getBoundingClientRect();
            if (cursor) {
                const rect = cursor.getBoundingClientRect();
                // Ensure hand stays within output bounds
                let left = rect.left - outputRect.left + 10;
                let top = rect.top - outputRect.top;
                // Clamp left position to prevent overflow
                left = Math.max(0, Math.min(left, outputRect.width - hand.offsetWidth));
                hand.style.left = left + 'px';
                hand.style.top = top + 'px';
            } else {
                const lastChild = output.lastChild;
                if (lastChild && lastChild.nodeType === Node.ELEMENT_NODE) {
                    const rect = lastChild.getBoundingClientRect();
                    let left = rect.right - outputRect.left + 10;
                    let top = rect.top - outputRect.top;
                    left = Math.max(0, Math.min(left, outputRect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                } else {
                    const tempSpan = document.createElement('span');
                    tempSpan.style.display = 'inline-block';
                    tempSpan.style.width = '1px';
                    output.appendChild(tempSpan);
                    const rect = tempSpan.getBoundingClientRect();
                    let left = rect.left - outputRect.left + 10;
                    let top = rect.top - outputRect.top;
                    left = Math.max(0, Math.min(left, outputRect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                    tempSpan.remove();
                }
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
