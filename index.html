<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maths Equation Editor</title>
    <!-- MathJax Configuration (AsciiMath + LaTeX) -->
    <script>
        MathJax = {
            loader: {
                load: ['input/asciimath', 'input/tex', 'output/chtml']
            },
            asciimath: {
                delimiters: [['`', '`']]
            },
            tex: {
                inlineMath: [['$', '$']],
                processEscapes: true
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/startup.js" async></script>
    <!-- html2canvas for frame capture -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- gif.js for GIF export -->
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #1c2526;
            color: #e0e0e0;
        }
        h1, p, li {
            color: #e0e0e0;
        }
        #header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #header-row h1 {
            margin: 0;
        }
        #header-row .menu-buttons {
            display: flex;
            gap: 10px;
        }
        #header-row button,
        #controls-row button,
        dialog button {
            padding: 8px 12px;
            font-size: 16px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
            cursor: pointer;
        }
        #header-row button:hover,
        #controls-row button:hover,
        dialog button:hover {
            background-color: #5a5a5a;
        }
        #input {
            width: 100%;
            height: 100px;
            font-size: 18px;
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 10px;
            margin-top: 10px;
            box-sizing: border-box;
        }
        #output {
            font-size: 24px;
            position: relative;
            min-height: 200px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            max-width: 100%;
            box-sizing: border-box;
            background-color: #ccff00; /* üçã greenlemon */
            color: #000000;            /* black text */
            border: 1px solid #aaa;
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
        }
        #hand {
            position: absolute;
            font-size: 30px;
            transform: rotate(45deg);
            transition: left 0.1s ease, top 0.1s ease, transform 0.5s ease, opacity 0.5s ease 0.5s;
            animation: float 1.5s ease-in-out infinite;
            opacity: 1;
            color: #000000; /* black for visibility */
        }
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(45deg); }
            50% { transform: translateY(-5px) rotate(45deg); }
        }
        #output.finished #hand {
            animation: none;
            transform: rotate(120deg) translate(50px, 50px);
            opacity: 0;
        }
        #cursor {
            display: inline-block;
            width: 3px;               /* thick cursor */
            height: 1.2em;
            background: #ff0000;      /* red */
            vertical-align: middle;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        dialog {
            width: 70vw;
            height: 70vh;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
        }
        dialog button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #4a4a4a;
            padding: 8px;
            text-align: left;
            color: #e0e0e0;
        }
        th {
            background-color: #3a3a3a;
        }
        #controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        #controls-row-left, #controls-row-right {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls-row select,
        #controls-row input[type="range"] {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
        }
        #speed-slider {
            width: 100px;
        }
        #controls {
            margin-top: 10px;
        }
        #symbols-table td {
            text-align: center;
            cursor: pointer;
            padding: 10px;
        }
        #symbols-table td:hover {
            background-color: #5a5a5a;
        }
        .rendering {
            background-color: #5a5a5a !important;
            cursor: not-allowed !important;
        }
        #resolution-container {
            text-align: right;
            margin: 5px 0;
            display: none;
        }
        #resolution-container select {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
            padding: 8px;
        }
    </style>
</head>
<body>
    <div id="header-row">
        <h1>Maths Equation Editor</h1>
        <div class="menu-buttons">
            <button onclick="showDialog('examples')">Examples</button>
            <button onclick="showDialog('history')">History</button>
            <button onclick="showDialog('help')">Help</button>
            <button onclick="showDialog('symbols')">Symbols</button>
        </div>
    </div>
    <div id="controls-row">
        <div id="controls-row-left">
            <button id="play-pause-btn" onclick="playPauseAnimation()">‚ñ∂Ô∏è</button>
            <button onclick="stopAnimation()">‚èπÔ∏è</button>
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div id="controls-row-right">
            <button onclick="undo()">‚Ü∫</button>
            <button onclick="redo()">‚Üª</button>
            <button onclick="clearOutput()">‚Ü©</button>
            <select id="download-format" onchange="updateResolutionOptions()">
                <optgroup label="--Image--">
                    <option value="png">Save as PNG</option>
                    <option value="jpg">Save as JPG</option>
                    <option value="webp">Save as WebP</option>
                </optgroup>
                <optgroup label="--Animation--">
                    <option value="gif">Save as GIF</option>
                    <option value="webm">Save as WebM</option>
                </optgroup>
            </select>
            <button id="download-btn" onclick="downloadOutput()">üì•</button>
        </div>
    </div>
    <div id="resolution-container">
        <select id="resolution-select">
            <option value="426x240">240p (426√ó240)</option>
            <option value="640x360">360p (640√ó360)</option>
            <option value="854x480">480p (854√ó480)</option>
            <option value="1280x720" selected>720p (1280√ó720)</option>
            <option value="1920x1080">1080p (1920√ó1080)</option>
        </select>
    </div>
    <div id="output"></div>
    <div id="controls">
        <textarea id="input" placeholder="e.g., f(x) = { -x if x < 0; 0 if x = 0; x if x > 0 }"></textarea>
        <div style="text-align: right; margin: 10px 0; display: flex; justify-content: flex-end; gap: 10px;">
            <button id="record-btn" onclick="toggleRecording()">‚è∫Ô∏è Record</button>
            <button id="start-btn" onclick="startAnimation()">Start Animation</button>
        </div>
    </div>
    <canvas id="captureCanvas" style="display: none;"></canvas>

    <!-- Dialogs -->
    <dialog id="examplesDialog">
        <h2>Mathematical Expression Examples</h2>
        <h3>Functional Expressions</h3>
        <ul>
            <li>Linear: ( f(x) = 2x + 3 )</li>
            <li>Quadratic: ( f(x) = x^2 + 2x + 1 )</li>
            <li>Piecewise (textbook style): ( f(x) = { -x if x < 0; 0 if x = 0; x if x > 0 } )</li>
        </ul>
        <h3>Trigonometric Expressions</h3>
        <ul><li>Basic: ( sin x + cos y )</li></ul>
        <h3>Calculus</h3>
        <ul><li>Limit: ( lim_(x->0) (sin x)/x = 1 )</li></ul>
        <button onclick="closeDialog('examples')">Close ‚ùå</button>
    </dialog>

    <dialog id="historyDialog">
        <h2>History</h2>
        <table><thead><tr><th>Title</th><th>Description</th><th>Date</th><th>Time</th></tr></thead><tbody id="historyBody"></tbody></table>
        <button onclick="closeDialog('history')">Close ‚ùå</button>
    </dialog>

    <dialog id="helpDialog">
        <h2>Help</h2>
        <p>Type math inside parentheses. For piecewise functions, use:</p>
        <code>( f(x) = { -x if x < 0; 0 if x = 0; x if x > 0 } )</code>
        <p>Click "‚è∫Ô∏è Record" before "Start Animation" to capture animation.</p>
        <button onclick="closeDialog('help')">Close ‚ùå</button>
    </dialog>

    <dialog id="symbolsDialog">
        <h2>Mathematical Symbols</h2>
        <p>Click to copy.</p>
        <table id="symbols-table">
            <tr><th>Symbol</th><th>Code</th><th>Description</th></tr>
            <tr><td>‚àà</td><td>in</td><td>Element of</td></tr>
            <tr><td>‚àÄ</td><td>forall</td><td>For all</td></tr>
        </table>
        <button onclick="closeDialog('symbols')">Close ‚ùå</button>
    </dialog>

    <script>
        let entries = [];
        let currentOutput = '';
        let undoStack = [];
        let redoStack = [];
        let history = JSON.parse(localStorage.getItem('mathHistory')) || [];
        let isAnimating = false;
        let isPaused = false;
        let animationController = null;
        let isRecording = false;
        let recordedFrames = [];
        const FRAME_RATE = 10;
        let frameCaptureInterval = null;

        function toggleRecording() {
            const btn = document.getElementById('record-btn');
            if (isRecording) {
                isRecording = false;
                clearInterval(frameCaptureInterval);
                btn.textContent = '‚è∫Ô∏è Record';
                btn.style.backgroundColor = '#4a4a4a';
            } else {
                if (isAnimating) {
                    alert('Stop current animation before recording.');
                    return;
                }
                recordedFrames = [];
                isRecording = true;
                btn.textContent = '‚èπÔ∏è Stop';
                btn.style.backgroundColor = '#c00';
            }
        }

        function updateResolutionOptions() {
            const format = document.getElementById('download-format').value;
            const container = document.getElementById('resolution-container');
            if (format === 'gif' || format === 'webm') {
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }
        }

        function processMathContent(str) {
            if (!str.startsWith('(') || !str.endsWith(')')) {
                if (str === 'forall') return 'forall';
                str = str.replace(/\[([^\[]*?)\]/g, (match, p1) => '[[' + p1.replace(/;\s*/g, '],[') + ']]');
                str = str.replace(/C\(([\w+]+),\s*([\w+]+)\)/g, 'binom($1)($2)');
                str = str.replace(/P\(([\w+]+),\s*([\w+]+)\)/g, '^$1 P_$2');
                str = str.replace(/\(\s*det\((.+?)\)\s*\)/g, '|$1|');
                str = str.replace(/cross/g, 'xx');
                str = str.replace(/i\^/g, 'hat i');
                str = str.replace(/j\^/g, 'hat j');
                str = str.replace(/k\^/g, 'hat k');
                return str;
            }

            let inner = str.slice(1, -1).trim();
            const piecewiseRegex = /^(.*?=)?\s*{\s*([^}]+)\s*}$/;
            const match = inner.match(piecewiseRegex);

            if (match) {
                const prefix = (match[1] || '').trim();
                const body = match[2];
                const cases = body.split(';').map(c => c.trim()).filter(c => c);
                const latexCases = cases.map(c => {
                    let expr, cond;
                    if (c.includes(' if ')) {
                        [expr, cond] = c.split(/ if /, 2);
                    } else if (c.includes(',')) {
                        [expr, cond] = c.split(',', 2);
                    } else {
                        expr = c;
                        cond = '';
                    }
                    expr = expr.trim();
                    cond = cond ? cond.trim() : '';
                    if (cond) {
                        return `${expr} & \\text{if } ${cond}`;
                    } else {
                        return `${expr} &`;
                    }
                }).join(' \\\\ ');
                const latex = `${prefix} \\begin{cases} ${latexCases} \\end{cases}`;
                return `$${latex}$`;
            }

            const mathConversions = {
                'greater than or equal to': '>=',
                'less than or equal to': '<=',
                'greater than': '>',
                'less than': '<',
                'equal to': '=',
                'not equal to': '!=',
                'for all': 'forall',
                'there exists': 'exists',
                'x in y': 'x in y',
                'x not in y': 'x notin y',
                'subset of': 'subset',
                'superset of': 'supset'
            };
            return mathConversions[inner] || inner;
        }

        function detectMathExpressions(text) {
            const segments = [];
            let i = 0;
            const n = text.length;
            let current = '';
            let mode = 'text';
            let parenDepth = 0;

            while (i < n) {
                const char = text.charAt(i);
                if (mode === 'text') {
                    if (char === '(') {
                        if (current) {
                            segments.push({type: 'text', content: current});
                            current = '';
                        }
                        mode = 'math';
                        parenDepth = 1;
                        current = char;
                    } else {
                        current += char;
                    }
                    i++;
                } else {
                    current += char;
                    if (char === '(') {
                        parenDepth++;
                    } else if (char === ')') {
                        parenDepth--;
                        if (parenDepth === 0) {
                            mode = 'text';
                            segments.push({type: 'math', content: current});
                            current = '';
                        }
                    }
                    i++;
                }
            }
            if (current) segments.push({type: mode, content: current});
            return segments;
        }

        async function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            isPaused = false;
            animationController = { cancelled: false };
            const inputText = document.getElementById('input').value;
            if (!inputText) {
                isAnimating = false;
                return;
            }

            const segments = detectMathExpressions(inputText);
            const output = document.getElementById('output');
            const startBtn = document.getElementById('start-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            startBtn.disabled = true;
            playPauseBtn.textContent = '‚è∏Ô∏è';
            output.classList.remove('finished');
            output.innerHTML = currentOutput;

            const hand = document.createElement('span');
            hand.id = 'hand';
            hand.textContent = '‚úçÔ∏è';
            hand.style.opacity = '1';

            let currentText = currentOutput ? currentOutput + '<br>' : '';
            const baseCharDelay = 50;
            const baseWordDelay = 200;
            const speed = parseFloat(document.getElementById('speed-slider').value);
            const charDelay = baseCharDelay / speed;
            const wordDelay = baseWordDelay / speed;

            if (isRecording) {
                recordedFrames = [];
                clearInterval(frameCaptureInterval);
                frameCaptureInterval = setInterval(async () => {
                    if (!isAnimating) return;
                    try {
                        const canvas = await html2canvas(output, {
                            backgroundColor: '#ccff00', // ‚úÖ greenlemon
                            scale: 1
                        });
                        recordedFrames.push({ canvas });
                    } catch (e) {
                        console.warn('Frame capture failed', e);
                    }
                }, 1000 / FRAME_RATE);
            }

            for (let segment of segments) {
                if (animationController.cancelled) break;
                if (segment.type === 'text') {
                    const parts = segment.content.split(/(\s+)/).filter(p => p);
                    for (let part of parts) {
                        if (animationController.cancelled) break;
                        for (let char of part) {
                            if (isPaused || animationController.cancelled) {
                                while (isPaused && !animationController.cancelled) await delay(100);
                                if (animationController.cancelled) break;
                            }
                            currentText += char;
                            output.innerHTML = currentText + '<span id="cursor"></span>';
                            output.appendChild(hand);
                            await typesetMathJax();
                            updateHandPosition(hand);
                            await delay(charDelay);
                        }
                        await delay(wordDelay);
                    }
                } else {
                    if (animationController.cancelled) break;
                    const mathStart = currentText.length;
                    for (let char of segment.content) {
                        if (isPaused || animationController.cancelled) {
                            while (isPaused && !animationController.cancelled) await delay(100);
                            if (animationController.cancelled) break;
                        }
                        currentText += char;
                        output.innerHTML = currentText + '<span id="cursor"></span>';
                        output.appendChild(hand);
                        await typesetMathJax();
                        updateHandPosition(hand);
                        await delay(charDelay);
                    }
                    if (animationController.cancelled) break;
                    const processed = processMathContent(segment.content);

                    let mathOutput;
                    if (typeof processed === 'string' && processed.startsWith('$') && processed.endsWith('$')) {
                        mathOutput = processed;
                    } else {
                        mathOutput = '`' + processed + '`';
                    }

                    currentText = currentText.slice(0, mathStart) + mathOutput + currentText.slice(mathStart + segment.content.length);
                    output.innerHTML = currentText + '<span id="cursor"></span>';
                    await typesetMathJax();
                    updateHandPosition(hand);
                    await delay(200);
                }
            }

            if (!animationController.cancelled) {
                output.innerHTML = currentText;
                await typesetMathJax();
                output.appendChild(hand);
                updateHandPosition(hand);
                output.classList.add('finished');
                await delay(1000);
                hand.remove();

                entries.push(inputText);
                undoStack.push([...entries]);
                redoStack = [];
                history.push({
                    title: `Input ${history.length + 1}`,
                    description: inputText,
                    date: new Date().toLocaleDateString(),
                    time: new Date().toLocaleTimeString()
                });
                localStorage.setItem('mathHistory', JSON.stringify(history));
                currentOutput = entries.join('<br>');
            }

            startBtn.disabled = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            isAnimating = false;
            animationController = null;
            if (isRecording && frameCaptureInterval) {
                clearInterval(frameCaptureInterval);
            }
        }

        function playPauseAnimation() {
            if (!isAnimating) {
                startAnimation();
            } else {
                isPaused = !isPaused;
                document.getElementById('play-pause-btn').textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
            }
        }

        function stopAnimation() {
            if (!isAnimating) return;
            animationController.cancelled = true;
            isPaused = false;
            isAnimating = false;
            clearInterval(frameCaptureInterval);
            const output = document.getElementById('output');
            output.innerHTML = currentOutput;
            output.classList.remove('finished');
            const hand = document.querySelector('#hand');
            if (hand) hand.remove();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('play-pause-btn').textContent = '‚ñ∂Ô∏è';
            typesetMathJax();
        }

        function undo() {
            if (undoStack.length) {
                redoStack.push([...entries]);
                entries = undoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function redo() {
            if (redoStack.length) {
                undoStack.push([...entries]);
                entries = redoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function clearOutput() {
            entries = [];
            undoStack = [];
            redoStack = [];
            currentOutput = '';
            document.getElementById('output').innerHTML = '';
        }

        async function downloadOutput() {
            const format = document.getElementById('download-format').value;
            const container = document.getElementById('resolution-container');
            const resValue = container.style.display === 'none' 
                ? '1280x720' 
                : document.getElementById('resolution-select').value;
            const [w, h] = resValue.split('x').map(Number);
            const downloadBtn = document.getElementById('download-btn');

            if ((format === 'gif' || format === 'webm') && recordedFrames.length > 0) {
                downloadBtn.innerHTML = '.Rendering...';
                downloadBtn.classList.add('rendering');
                downloadBtn.disabled = true;

                try {
                    if (format === 'gif') {
                        await renderAndDownloadGIF(w, h);
                    } else if (format === 'webm') {
                        alert('WebM is experimental. GIF recommended.');
                        await renderAndDownloadWebM(w, h);
                    }
                } catch (err) {
                    console.error('Render failed:', err);
                    alert('Export failed. Try fewer frames.');
                } finally {
                    downloadBtn.innerHTML = 'üì•';
                    downloadBtn.classList.remove('rendering');
                    downloadBtn.disabled = false;
                }
            } else {
                await downloadImage(format, w, h);
            }
        }

        async function downloadImage(format, width, height) {
            const output = document.getElementById('output');
            try {
                const canvas = await html2canvas(output, { 
                    backgroundColor: '#ccff00', // ‚úÖ greenlemon
                    scale: 1 
                });
                const resized = resizeCanvas(canvas, width, height);
                let dataUrl;
                if (format === 'jpg') {
                    dataUrl = resized.toDataURL('image/jpeg', 0.9);
                } else {
                    dataUrl = resized.toDataURL('image/' + (format === 'webp' ? 'webp' : 'png'));
                }
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `math_output.${format}`;
                a.click();
            } catch (err) {
                alert('Image export failed.');
            }
        }

        function renderAndDownloadGIF(width, height) {
            return new Promise((resolve, reject) => {
                const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    width: width,
                    height: height,
                    repeat: 0,
                    transparent: '#ccff00' // ‚úÖ greenlemon
                });

                recordedFrames.forEach(({ canvas }) => {
                    const resized = resizeCanvas(canvas, width, height);
                    gif.addFrame(resized, { delay: 1000 / FRAME_RATE });
                });

                gif.on('finished', function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `math_animation_${Date.now()}.gif`;
                    a.click();
                    URL.revokeObjectURL(url);
                    resolve();
                });

                gif.on('error', reject);
                gif.render();
            });
        }

        async function renderAndDownloadWebM(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const stream = canvas.captureStream(FRAME_RATE);
            const mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
            const chunks = [];

            mediaRecorder.ondataavailable = e => chunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `math_animation_${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);
            };

            mediaRecorder.start();

            for (let i = 0; i < recordedFrames.length; i++) {
                const frame = recordedFrames[i].canvas;
                ctx.fillStyle = '#ccff00'; // ‚úÖ greenlemon
                ctx.fillRect(0, 0, width, height);
                ctx.drawImage(frame, 0, 0, width, height);
                await delay(1000 / FRAME_RATE);
            }

            setTimeout(() => mediaRecorder.stop(), 100);
        }

        function resizeCanvas(src, width, height) {
            const temp = document.createElement('canvas');
            temp.width = width;
            temp.height = height;
            const ctx = temp.getContext('2d');
            ctx.fillStyle = '#ccff00'; // ‚úÖ greenlemon
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(src, 0, 0, width, height);
            return temp;
        }

        function showDialog(id) {
            document.getElementById(id + 'Dialog').showModal();
            if (id === 'history') populateHistory();
            else if (id === 'symbols') setupSymbolTable();
        }

        function closeDialog(id) {
            document.getElementById(id + 'Dialog').close();
        }

        function populateHistory() {
            const tbody = document.getElementById('historyBody');
            tbody.innerHTML = '';
            history.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${item.title}</td>
                    <td>${item.description}</td>
                    <td>${item.date}</td>
                    <td>${item.time}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function setupSymbolTable() {
            const rows = document.getElementById('symbols-table').getElementsByTagName('tr');
            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                cells[0].onclick = () => copyToClipboard(cells[0].textContent, 'Symbol');
                cells[1].onclick = () => copyToClipboard(cells[1].textContent, 'Code');
            }
        }

        function copyToClipboard(text, type) {
            navigator.clipboard.writeText(text).then(() => {
                alert(`${type} "${text}" copied!`);
            }).catch(err => console.error('Copy failed:', err));
        }

        async function typesetMathJax() {
            try {
                await MathJax.typesetPromise([document.getElementById('output')]);
            } catch (err) {
                console.error('MathJax error:', err);
            }
        }

        function updateHandPosition(hand) {
            const cursor = document.getElementById('cursor');
            const output = document.getElementById('output');
            const rect = output.getBoundingClientRect();
            if (cursor) {
                const cRect = cursor.getBoundingClientRect();
                let left = cRect.left - rect.left + 10;
                let top = cRect.top - rect.top;
                left = Math.max(0, Math.min(left, rect.width - hand.offsetWidth));
                hand.style.left = left + 'px';
                hand.style.top = top + 'px';
            } else {
                const last = output.lastChild;
                if (last && last.nodeType === Node.ELEMENT_NODE) {
                    const lRect = last.getBoundingClientRect();
                    let left = lRect.right - rect.left + 10;
                    let top = lRect.top - rect.top;
                    left = Math.max(0, Math.min(left, rect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                } else {
                    const span = document.createElement('span');
                    span.style.display = 'inline-block';
                    span.style.width = '1px';
                    output.appendChild(span);
                    const sRect = span.getBoundingClientRect();
                    let left = sRect.left - rect.left + 10;
                    let top = sRect.top - rect.top;
                    left = Math.max(0, Math.min(left, rect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                    span.remove();
                }
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
