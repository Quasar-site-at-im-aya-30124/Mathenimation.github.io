<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathenimation: Maths Equation Editor</title>
    <!-- MathJax Configuration -->
    <script>
        MathJax = {
            loader: { load: ['input/asciimath', 'output/chtml'] },
            asciimath: { 
                delimiters: [['`', '`']],
                symbols: {
                    '‚àö': ['\u221A', 1],
                    'abs': ['|', 1],
                    'mod': ['\u0025', 1],
                    '‚â°': ['\u2261', 1],
                    'log': ['\u006C\u006F\u0067', 1],
                    'exp': ['\u0065\u005E', 1],
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" async></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #1c2526;
            color: #e0e0e0;
        }
        h1, p, li {
            color: #e0e0e0;
        }
        #header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #header-row h1 {
            margin: 0;
        }
        #header-row .menu-buttons {
            display: flex;
            gap: 10px;
        }
        #header-row button,
        #controls-row button,
        dialog button {
            padding: 8px 12px;
            font-size: 16px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
            cursor: pointer;
        }
        #header-row button:hover,
        #controls-row button:hover,
        dialog button:hover {
            background-color: #5a5a5a;
        }
        #input {
            width: 100%;
            height: 100px;
            font-size: 18px;
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 10px;
            margin-top: 10px;
            box-sizing: border-box;
        }
        #output {
            font-size: 24px;
            position: relative;
            min-height: 200px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            max-width: 100%;
            box-sizing: border-box;
            background-color: lawngreen; /* ‚úÖ Lawngreen background */
            color: #000; /* Dark text for contrast on lawngreen */
            border: 1px solid #4a4a4a;
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
        }
        #hand {
            position: absolute;
            font-size: 50px; /* ‚úÖ Enlarged hand */
            transform: rotate(45deg);
            transition: left 0.1s ease, top 0.1s ease, transform 0.5s ease, opacity 0.5s ease 0.5s;
            animation: float 1.5s ease-in-out infinite;
            opacity: 1;
            color: #000; /* Visible on lawngreen */
            pointer-events: none;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(45deg); }
            50% { transform: translateY(-8px) rotate(45deg); }
        }
        #output.finished #hand {
            animation: none;
            transform: rotate(120deg) translate(70px, 70px);
            opacity: 0;
        }
        #cursor {
            display: inline-block;
            width: 7px; /* ‚úÖ Thickness 7px */
            height: 1.2em;
            background: blue; /* ‚úÖ Blue cursor */
            vertical-align: middle;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        dialog {
            width: 70vw;
            height: 70vh;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
        }
        dialog button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #4a4a4a;
            padding: 8px;
            text-align: left;
            color: #e0e0e0;
        }
        th {
            background-color: #3a3a3a;
        }
        #controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        #controls-row-left,
        #controls-row-right {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls-row select,
        #controls-row input[type="range"] {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
        }
        #controls-row select {
            padding: 8px;
        }
        #controls-row select option {
            background-color: #2e2e2e;
            color: #e0e0e0;
        }
        #speed-slider {
            width: 100px;
            vertical-align: middle;
        }
        #controls {
            margin-top: 10px;
        }
        #symbols-table td {
            text-align: center;
            cursor: pointer;
            padding: 10px;
        }
        #symbols-table td:hover {
            background-color: #5a5a5a;
        }
        /* WebM resolution dropdown */
        #webm-resolutions {
            display: none;
            position: absolute;
            background: #2e2e2e;
            border: 1px solid #666;
            z-index: 1000;
            padding: 5px;
            margin-top: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }
        #webm-resolutions div {
            padding: 6px 10px;
            cursor: pointer;
        }
        #webm-resolutions div:hover {
            background: #4a4a4a;
        }
        #record-btn.recording {
            background-color: #ff5555 !important;
        }
    </style>
</head>
<body>
    <div id="header-row">
        <h1>Mathenimation</h1>
        <div class="menu-buttons">
            <button onclick="showDialog('examples')">Examples</button>
            <button onclick="showDialog('history')">History</button>
            <button onclick="showDialog('help')">Help</button>
            <button onclick="showDialog('symbols')">Symbols</button>
        </div>
    </div>
    <div id="controls-row">
        <div id="controls-row-left">
            <button id="play-pause-btn" onclick="playPauseAnimation()">‚ñ∂Ô∏è</button>
            <button onclick="stopAnimation()">‚èπÔ∏è</button>
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div id="controls-row-right">
            <button onclick="undo()">‚Ü∫</button>
            <button onclick="redo()">‚Üª</button>
            <button onclick="clearOutput()">‚Ü©</button>
            <select id="download-format" onchange="handleDownloadFormatChange()">
                <optgroup label="--Image--">
                    <option value="png">Save as PNG</option>
                    <option value="jpg">Save as JPG</option>
                </optgroup>
                <optgroup label="--Animation--">
                    <option value="gif">Save as GIF</option>
                    <option value="webm">Save as WebM</option>
                </optgroup>
            </select>
            <button onclick="downloadOutput()">üì•</button>
        </div>
    </div>
    <div id="output"></div>
    <div id="controls">
        <textarea id="input" placeholder="e.g., x (is greater than to) y"></textarea>
        <div style="text-align: right; margin: 10px 0; display: flex; justify-content: flex-end; gap: 10px;">
            <button id="record-btn" onclick="toggleRecording()">‚è∫Ô∏è Record</button>
            <button id="start-btn" onclick="startAnimation()">Start Animation</button>
        </div>
    </div>
    <canvas id="captureCanvas" style="display: none;"></canvas>

    <!-- WebM Resolution Dropdown -->
    <div id="webm-resolutions"></div>

    <!-- Dialogs (unchanged from your original) -->
    <dialog id="examplesDialog">
        <h2>Examples</h2>
        <ul>
            <li>Monomial: (3x^2)</li>
            <li>Binomial: x + (2y)</li>
            <li>Trinomial: (x^2 + 2x + 1)</li>
            <li>Polynomial: (x^3 + 2x^2 - x + 5)</li>
            <li>Rational Expression: ((x + 1)/(x - 2))</li>
            <li>Irrational Expression: (‚àö(x + 2))</li>
            <li>Radical Expression: (root(3)(x^2 + 1))</li>
            <li>Square Root Expression: (sqrt(x + 1)) or (‚àö(x + 1))</li>
            <li>Exponential Expression: (exp(x)) or (2^x)</li>
            <li>Logarithmic Expression: (log(x)) or (log_2(x))</li>
            <li>Modulus (Absolute Value) Expression: |a| + |b| = (|a + b|)</li>
            <li>Modular Expression: x mod y = r ‚Üî (x ‚â° r (mod y))</li>
            <li>Fraction: (a/b)</li>
            <li>Integral: (int_0^1 x dx)</li>
            <li>Union: A (union) B</li>
            <li>Matrix: ([1,2;3,4])</li>
            <li>Limit: (lim_(x->0) sin x / x)</li>
            <li>Derivative: ((d/dx) x^2)</li>
            <li>Sum: (sum_(k=1)^n k)</li>
            <li>Product: (prod_(k=1)^n k)</li>
            <li>Vector: (vec(a) = <<1,2,3>>)</li>
            <li>Binomial Coefficient: (C(n,k)) or (binom(n)(k))</li>
            <li>Trigonometric Expression: (sin x + cos y)</li>
            <li>Inverse Trigonometric: (arcsin(x))</li>
            <li>Trigonometric Identity: (sin^2 x + cos^2 x = 1)</li>
            <li>Compound Angle: (sin(a + b) = sin a cos b + cos a sin b)</li>
            <li>Multiple Angle: (cos 2x = cos^2 x - sin^2 x)</li>
            <li>Differential Expression: ((d/dx) sin x = cos x)</li>
            <li>Integral Expression: (int_0^infty e^{-x} dx = 1)</li>
            <li>Limit Expression: (lim_(x->0) (sin x)/x = 1)</li>
            <li>Series Expression: (sum_(n=1)^infty 1/n^2 = pi^2/6)</li>
            <li>Mean: (bar x = (sum x_i)/n)</li>
            <li>Variance: (sigma^2 = (sum (x_i - bar x)^2)/n)</li>
            <li>Probability: (P(A union B) = P(A) + P(B) - P(A intersect B))</li>
            <li>Combinations: (C(n,r) = (n!)/(r!(n-r)!))</li>
            <li>Permutations: (P(n,r) = (n!)/(n-r)!)</li>
            <li>Vector Expression: (r = a i^ + b j^ + c k^)</li>
            <li>Dot Product: ((vec A dot B))</li>
            <li>Cross Product: ((vec A cross B))</li>
            <li>Matrix Expression: (A = [1,2,3;4,5,6])</li>
            <li>Determinant: (det(A)) or ((det(A)))</li>
            <li>Inverse Matrix: (A^(-1))</li>
            <li>Complex Number Expression: (z = a + b i)</li>
            <li>Set Expression: (A = {1,2,3})</li>
            <li>Membership: (x in A) or (x belong to A)</li>
            <li>Logical Expression: (p ^^ q)</li>
            <li>Quantified Expression: (for all) (x in R), (x^2 (greater than or equal) 0)</li>
            <li>Parametric Expression: (x = r cos theta, y = r sin theta)</li>
            <li>Polar Expression: (r = theta)</li>
            <li>Tensor Expression: (T_(i j))</li>
            <li>Functional Analysis Expression: (||f|| = sqrt(int |f(x)|^2 dx))</li>
            <li>Topology Expression: (open set U)</li>
            <li>Algebraic Structure Expression: (group G)</li>
        </ul>
        <button onclick="closeDialog('examples')">Close ‚ùå</button>
    </dialog>

    <dialog id="historyDialog">
        <h2>History</h2>
        <table>
            <thead>
                <tr>
                    <th>Title</th>
                    <th>Description</th>
                    <th>Date</th>
                    <th>Time</th>
                </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
        <button onclick="closeDialog('history')">Close ‚ùå</button>
    </dialog>

    <dialog id="helpDialog">
        <h2>Help</h2>
        <p>Here are some tips for using the Maths Equation Editor:</p>
        <ul>
            <li>Text inside parentheses () is treated as a math expression and converted to math symbols or notation.</li>
            <li>Text outside parentheses is treated as plain text and animated without conversion.</li>
            <li>Use specific phrases in parentheses for symbols:
                <ul>
                    <li>(greater than) ‚Üí > </li>
                    <li>(less than) ‚Üí < </li>
                    <li>(greater than or equal to) ‚Üí ‚â• </li>
                    <li>(less than or equal to) ‚Üí ‚â§ </li>
                    <li>(equal to) ‚Üí = </li>
                    <li>(not equal to) ‚Üí ‚â† </li>
                    <li>(for all) ‚Üí ‚àÄ </li>
                    <li>(there exists) ‚Üí ‚àÉ </li>
                    <li>(x in y) ‚Üí x ‚àà y </li>
                    <li>(x not in y) ‚Üí x ‚àâ y </li>
                    <li>(subset of) ‚Üí ‚äÇ </li>
                    <li>(superset of) ‚Üí ‚äÉ </li>
                </ul>
            </li>
            <li>For other math expressions, use AsciiMath syntax inside parentheses:
                <ul>
                    <li>(x^2) renders as x¬≤</li>
                    <li>(a/b) renders as a fraction a over b</li>
                    <li>(sqrt(x)) renders as ‚àöx</li>
                    <li>(int_0^1 x dx) renders as an integral</li>
                </ul>
            </li>
            <li>Outside parentheses, use 'forall' to render ‚àÄ, e.g., 'forall x' ‚Üí '‚àÄ x'.</li>
            <li>Examples of mixed text:
                <ul>
                    <li>x (is greater than to) y ‚Üí x ‚â• y</li>
                    <li>(for all) (x in y) ‚Üí ‚àÄ x ‚àà y</li>
                    <li>for all (x in y) ‚Üí for all x ‚àà y</li>
                    <li>forall (x in y) ‚Üí ‚àÄ x ‚àà y</li>
                </ul>
            </li>
            <li>For matrices, use [ ; ]: e.g., ([1,2;3,4]) renders as a 2x2 matrix.</li>
            <li>For combinations, use C(n,r): e.g., (C(n,r)) renders as binom(n)(r).</li>
            <li>For permutations, use P(n,r): e.g., (P(n,r)) renders as ^n P_r.</li>
            <li>For determinants, use det: e.g., ((det(A))) renders as |A|.</li>
            <li>For vectors, use i^, j^, k^: e.g., (a i^ + b j^) renders with hats on i, j.</li>
            <li>Use the Examples dialog for more syntax ideas.</li>
        </ul>
        <button onclick="closeDialog('help')">Close ‚ùå</button>
    </dialog>

    <dialog id="symbolsDialog">
        <h2>Mathematical Symbols</h2>
        <p>Click a symbol to copy its AsciiMath code or character to the clipboard.</p>
        <table id="symbols-table">
            <tr><th>Symbol</th><th>AsciiMath Code</th><th>Description</th></tr>
            <tr><td>‚àà</td><td>in</td><td>Element of</td></tr>
            <tr><td>‚àÄ</td><td>forall</td><td>For all</td></tr>
            <tr><td>‚â•</td><td>>=</td><td>Greater than or equal to</td></tr>
            <tr><td>‚â§</td><td><=</td><td>Less than or equal to</td></tr>
            <tr><td>‚â†</td><td>!=</td><td>Not equal to</td></tr>
            <tr><td>‚àÇ</td><td>partial</td><td>Partial derivative</td></tr>
            <tr><td>‚àÉ</td><td>exists</td><td>There exists</td></tr>
            <tr><td>‚àá</td><td>grad</td><td>Gradient (nabla)</td></tr>
            <tr><td>‚àã</td><td>ni</td><td>Contains as member</td></tr>
            <tr><td>‚àè</td><td>prod</td><td>Product</td></tr>
            <tr><td>‚àô</td><td>cdot</td><td>Dot product</td></tr>
            <tr><td>‚àù</td><td>prop</td><td>Proportional to</td></tr>
            <tr><td>‚àû</td><td>infty</td><td>Infinity</td></tr>
            <tr><td>‚à™</td><td>union</td><td>Union</td></tr>
            <tr><td>‚à©</td><td>intersect</td><td>Intersection</td></tr>
            <tr><td>‚à®</td><td>vv</td><td>Logical OR</td></tr>
            <tr><td>‚àß</td><td>^^</td><td>Logical AND</td></tr>
            <tr><td>‚à†</td><td>angle</td><td>Angle</td></tr>
            <tr><td>‚à•</td><td>||</td><td>Parallel</td></tr>
            <tr><td>‚à´</td><td>int</td><td>Integral</td></tr>
            <tr><td>‚à¨</td><td>iint</td><td>Double integral</td></tr>
            <tr><td>‚àÆ</td><td>oint</td><td>Contour integral</td></tr>
            <tr><td>‚à¥</td><td>therefore</td><td>Therefore</td></tr>
            <tr><td>‚àµ</td><td>because</td><td>Because</td></tr>
            <tr><td>‚â™</td><td><<</td><td>Much less than</td></tr>
            <tr><td>‚â´</td><td>>></td><td>Much greater than</td></tr>
            <tr><td>‚äÇ</td><td>subset</td><td>Subset</td></tr>
            <tr><td>‚äÉ</td><td>supset</td><td>Superset</td></tr>
            <tr><td>‚äÜ</td><td>subseteq</td><td>Subset or equal to</td></tr>
            <tr><td>‚äá</td><td>supseteq</td><td>Superset or equal to</td></tr>
            <tr><td>‚äô</td><td>odot</td><td>Circle dot</td></tr>
            <tr><td>‚ä•</td><td>perp</td><td>Perpendicular</td></tr>
            <tr><td>¬π</td><td>^1</td><td>Superscript 1</td></tr>
            <tr><td>¬≤</td><td>^2</td><td>Superscript 2</td></tr>
            <tr><td>¬≥</td><td>^3</td><td>Superscript 3</td></tr>
            <tr><td>‚Å¥</td><td>^4</td><td>Superscript 4</td></tr>
            <tr><td>‚ÇÅ</td><td>_1</td><td>Subscript 1</td></tr>
            <tr><td>‚ÇÇ</td><td>_2</td><td>Subscript 2</td></tr>
            <tr><td>‚ÇÉ</td><td>_3</td><td>Subscript 3</td></tr>
            <tr><td>‚ÇÑ</td><td>_4</td><td>Subscript 4</td></tr>
            <tr><td>‚Åø</td><td>^n</td><td>Superscript n</td></tr>
            <tr><td>¬Ω</td><td>1/2</td><td>Fraction one-half</td></tr>
            <tr><td>‚Öì</td><td>1/3</td><td>Fraction one-third</td></tr>
            <tr><td>‚Öî</td><td>2/3</td><td>Fraction two-thirds</td></tr>
            <tr><td>¬º</td><td>1/4</td><td>Fraction one-quarter</td></tr>
            <tr><td>¬æ</td><td>3/4</td><td>Fraction three-quarters</td></tr>
            <tr><td>‚Öú</td><td>3/8</td><td>Fraction three-eighths</td></tr>
            <tr><td>‚Öù</td><td>5/8</td><td>Fraction five-eighths</td></tr>
            <tr><td>‚Öû</td><td>7/8</td><td>Fraction seven-eighths</td></tr>
            <tr><td>¬±</td><td>+-</td><td>Plus-minus</td></tr>
            <tr><td>Ôπô</td><td>(</td><td>Left parenthesis</td></tr>
            <tr><td>Ôπõ</td><td>{</td><td>Left brace</td></tr>
            <tr><td>Ôπú</td><td>}</td><td>Right brace</td></tr>
            <tr><td>Ôπû</td><td>)</td><td>Right parenthesis</td></tr>
            <tr><td>Ôπ§</td><td><</td><td>Less than</td></tr>
            <tr><td>Ôπ°</td><td>*</td><td>Asterisk (multiplication)</td></tr>
            <tr><td>Ôπ¢</td><td>+</td><td>Plus</td></tr>
            <tr><td>Ôπ¶</td><td>=</td><td>Equals</td></tr>
            <tr><td>Ôπ†</td><td>&</td><td>Ampersand (logical AND)</td></tr>
            <tr><td>Ôπü</td><td>#</td><td>Number sign</td></tr>
        </table>
        <button onclick="closeDialog('symbols')">Close ‚ùå</button>
    </dialog>

    <script>
        let entries = [];
        let currentOutput = '';
        let undoStack = [];
        let redoStack = [];
        let history = JSON.parse(localStorage.getItem('mathHistory')) || [];
        let isAnimating = false;
        let isPaused = false;
        let animationController = null;

        // ‚úÖ New recording state
        let isRecording = false;
        let recordedFrames = [];
        let selectedDownloadType = 'png';
        let selectedWebMResolution = '1280x720';

        function processMathContent(str) {
            const mathConversions = {
                'greater than': '>',
                'less than': '<',
                'greater than or equal to': '>=',
                'less than or equal to': '<=',
                'equal to': '=',
                'not equal to': '!=',
                'for all': 'forall',
                'there exists': 'exists',
                'x in y': 'x in y',
                'x not in y': 'x notin y',
                'subset of': 'subset',
                'superset of': 'supset'
            };

            if (!str.startsWith('(') || !str.endsWith(')')) {
                if (str === 'forall') return 'forall';
                str = str.replace(/\[([^\[]*?)\]/g, function(match, p1) {
                    return '[[' + p1.replace(/;\s*/g, '],[') + ']]';
                });
                str = str.replace(/C\(([\w+]+),\s*([\w+]+)\)/g, 'binom($1)($2)');
                str = str.replace(/P\(([\w+]+),\s*([\w+]+)\)/g, '^$1 P_$2');
                str = str.replace(/\(\s*det\((.+?)\)\s*\)/g, '|$1|');
                str = str.replace(/cross/g, 'xx');
                str = str.replace(/i\^/g, 'hat i');
                str = str.replace(/j\^/g, 'hat j');
                str = str.replace(/k\^/g, 'hat k');
                return str;
            }

            const inner = str.slice(1, -1).trim();
            return mathConversions[inner] || inner;
        }

        function detectMathExpressions(text) {
            const segments = [];
            let i = 0;
            const n = text.length;
            let current = '';
            let mode = 'text';
            let parenDepth = 0;

            while (i < n) {
                const char = text.charAt(i);
                if (mode === 'text') {
                    if (char === '(') {
                        if (current) {
                            segments.push({type: 'text', content: current});
                            current = '';
                        }
                        mode = 'math';
                        parenDepth = 1;
                        current = char;
                    } else {
                        current += char;
                    }
                    i++;
                } else {
                    current += char;
                    if (char === '(') {
                        parenDepth++;
                    } else if (char === ')') {
                        parenDepth--;
                        if (parenDepth === 0) {
                            mode = 'text';
                            segments.push({type: 'math', content: current});
                            current = '';
                        }
                    }
                    i++;
                }
            }

            if (current) {
                segments.push({type: mode, content: current});
            }
            return segments;
        }

        // ‚úÖ Capture current frame
        async function captureFrame() {
            if (!isRecording) return;
            const output = document.getElementById('output');
            const canvas = await html2canvas(output, {
                scale: 1,
                backgroundColor: 'lawngreen'
            });
            recordedFrames.push({
                timestamp: performance.now(),
                dataUrl: canvas.toDataURL('image/png')
            });
        }

        async function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            isPaused = false;
            animationController = { cancelled: false };
            const inputText = document.getElementById('input').value;
            if (!inputText) {
                isAnimating = false;
                return;
            }
            const segments = detectMathExpressions(inputText);
            const output = document.getElementById('output');
            const startBtn = document.getElementById('start-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const recordBtn = document.getElementById('record-btn');
            startBtn.disabled = true;
            playPauseBtn.textContent = '‚è∏Ô∏è';
            output.classList.remove('finished');

            output.innerHTML = currentOutput;

            const hand = document.createElement('span');
            hand.id = 'hand';
            hand.textContent = '‚úçÔ∏è';
            hand.style.opacity = '1';
            output.appendChild(hand);

            let currentText = currentOutput ? currentOutput + '<br>' : '';
            const baseCharDelay = 50;
            const baseWordDelay = 200;
            const speedSlider = document.getElementById('speed-slider');
            const speed = parseFloat(speedSlider.value);
            const charDelay = baseCharDelay / speed;
            const wordDelay = baseWordDelay / speed;

            for (let segment of segments) {
                if (animationController.cancelled) break;
                if (segment.type === 'text') {
                    const parts = segment.content.split(/(\s+)/).filter(part => part !== '');
                    for (let part of parts) {
                        if (animationController.cancelled) break;
                        for (let char of part) {
                            if (isPaused || animationController.cancelled) {
                                while (isPaused && !animationController.cancelled) {
                                    await delay(100);
                                }
                                if (animationController.cancelled) break;
                            }
                            currentText += char;
                            output.innerHTML = currentText + '<span id="cursor"></span>';
                            output.appendChild(hand);
                            await typesetMathJax();
                            updateHandPosition(hand);
                            await captureFrame(); // ‚úÖ Capture frame
                            await delay(charDelay);
                        }
                        await delay(wordDelay);
                    }
                } else {
                    if (animationController.cancelled) break;
                    const mathStart = currentText.length;
                    for (let char of segment.content) {
                        if (isPaused || animationController.cancelled) {
                            while (isPaused && !animationController.cancelled) {
                                await delay(100);
                            }
                            if (animationController.cancelled) break;
                        }
                        currentText += char;
                        output.innerHTML = currentText + '<span id="cursor"></span>';
                        output.appendChild(hand);
                        await typesetMathJax();
                        updateHandPosition(hand);
                        await captureFrame(); // ‚úÖ Capture frame
                        await delay(charDelay);
                    }
                    if (animationController.cancelled) break;
                    const processed = processMathContent(segment.content);
                    currentText = currentText.slice(0, mathStart) + '`' + processed + '`' + currentText.slice(mathStart + segment.content.length);
                    output.innerHTML = currentText + '<span id="cursor"></span>';
                    await typesetMathJax();
                    updateHandPosition(hand);
                    await captureFrame(); // ‚úÖ After conversion
                    await delay(200);
                }
            }

            if (!animationController.cancelled) {
                output.innerHTML = currentText;
                await typesetMathJax();
                output.appendChild(hand);
                updateHandPosition(hand);
                output.classList.add('finished');
                await captureFrame(); // ‚úÖ Final frame
                await delay(1000);
                hand.remove();

                entries.push(inputText);
                undoStack.push([...entries]);
                redoStack = [];
                history.push({
                    title: `Input ${history.length + 1}`,
                    description: inputText,
                    date: new Date().toLocaleDateString(),
                    time: new Date().toLocaleTimeString()
                });
                localStorage.setItem('mathHistory', JSON.stringify(history));
                currentOutput = entries.join('<br>');
            }

            startBtn.disabled = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            isAnimating = false;
            animationController = null;
        }

        function playPauseAnimation() {
            if (!isAnimating) {
                startAnimation();
            } else {
                isPaused = !isPaused;
                const playPauseBtn = document.getElementById('play-pause-btn');
                playPauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
            }
        }

        function stopAnimation() {
            if (!isAnimating) return;
            animationController.cancelled = true;
            isPaused = false;
            isAnimating = false;
            const output = document.getElementById('output');
            const startBtn = document.getElementById('start-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            output.innerHTML = currentOutput;
            output.classList.remove('finished');
            const hand = document.querySelector('#hand');
            if (hand) hand.remove();
            startBtn.disabled = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            typesetMathJax();
        }

        function undo() {
            if (undoStack.length) {
                redoStack.push([...entries]);
                entries = undoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function redo() {
            if (redoStack.length) {
                undoStack.push([...entries]);
                entries = redoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function clearOutput() {
            entries = [];
            undoStack = [];
            redoStack = [];
            currentOutput = '';
            document.getElementById('output').innerHTML = '';
        }

        // ‚úÖ Toggle recording
        function toggleRecording() {
            isRecording = !isRecording;
            const btn = document.getElementById('record-btn');
            if (isRecording) {
                recordedFrames = [];
                btn.textContent = '‚èπÔ∏è Finish';
                btn.classList.add('recording');
            } else {
                btn.textContent = '‚è∫Ô∏è Record';
                btn.classList.remove('recording');
            }
        }

        // ‚úÖ Handle download format change
        function handleDownloadFormatChange() {
            const format = document.getElementById('download-format').value;
            selectedDownloadType = format;
            const webmMenu = document.getElementById('webm-resolutions');
            if (format === 'webm') {
                const selectRect = document.getElementById('download-format').getBoundingClientRect();
                webmMenu.innerHTML = `
                    <div onclick="selectWebMResolution('426x240')">240p (426x240)</div>
                    <div onclick="selectWebMResolution('640x360')">360p (640x360)</div>
                    <div onclick="selectWebMResolution('854x480')">480p (854x480)</div>
                    <div onclick="selectWebMResolution('1280x720')">720p (1280x720 - HD)</div>
                    <div onclick="selectWebMResolution('1920x1080')">1080p (1920x1080 - FHD)</div>
                    <div onclick="selectWebMResolution('2560x1440')">1440p (2560x1440 - 2K)</div>
                    <div onclick="selectWebMResolution('3840x2160')">2160p (3840x2160 - 4K)</div>
                `;
                webmMenu.style.display = 'block';
                webmMenu.style.left = selectRect.left + 'px';
                webmMenu.style.top = (selectRect.bottom + window.scrollY) + 'px';
            } else {
                webmMenu.style.display = 'none';
            }
        }

        function selectWebMResolution(res) {
            selectedWebMResolution = res;
            document.getElementById('webm-resolutions').style.display = 'none';
        }

        // ‚úÖ Enhanced download
        async function downloadOutput() {
            if (isAnimating && !isPaused) {
                alert('Please wait until animation finishes.');
                return;
            }

            const output = document.getElementById('output');

            if (selectedDownloadType === 'png' || selectedDownloadType === 'jpg') {
                // Final frame only
                const canvas = await html2canvas(output, {
                    backgroundColor: 'lawngreen',
                    scale: 2
                });
                const mime = selectedDownloadType === 'jpg' ? 'image/jpeg' : 'image/png';
                const url = canvas.toDataURL(mime, selectedDownloadType === 'jpg' ? 0.92 : 1.0);
                triggerDownload(url, `math_output.${selectedDownloadType}`);
            } else if (selectedDownloadType === 'gif' || selectedDownloadType === 'webm') {
                if (recordedFrames.length === 0) {
                    alert('No animation recorded. Click "Record", then "Start Animation".');
                    return;
                }
                // Placeholder for actual encoding
                alert(`${selectedDownloadType.toUpperCase()} export is ready for integration with encoding libraries.`);
                // TODO: Integrate gif.js or webm-writer-js here
            }
        }

        function triggerDownload(dataUrl, filename) {
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = filename;
            a.click();
        }

        function showDialog(id) {
            const dialog = document.getElementById(id + 'Dialog');
            dialog.showModal();
            if (id === 'history') {
                populateHistory();
            } else if (id === 'symbols') {
                setupSymbolTable();
            }
        }

        function closeDialog(id) {
            document.getElementById(id + 'Dialog').close();
        }

        function populateHistory() {
            const tbody = document.getElementById('historyBody');
            tbody.innerHTML = '';
            history.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${item.title}</td>
                    <td>${item.description}</td>
                    <td>${item.date}</td>
                    <td>${item.time}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function setupSymbolTable() {
            const table = document.getElementById('symbols-table');
            const rows = table.getElementsByTagName('tr');
            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                cells[0].onclick = () => copyToClipboard(cells[0].textContent, 'Symbol');
                cells[1].onclick = () => copyToClipboard(cells[1].textContent, 'AsciiMath code');
            }
        }

        function copyToClipboard(text, type) {
            navigator.clipboard.writeText(text).then(() => {
                alert(`${type} "${text}" copied to clipboard!`);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        async function typesetMathJax() {
            try {
                await MathJax.typesetPromise([document.getElementById('output')]);
            } catch (err) {
                console.error('MathJax typesetting error:', err);
            }
        }

        function updateHandPosition(hand) {
            const cursor = document.getElementById('cursor');
            const output = document.getElementById('output');
            const outputRect = output.getBoundingClientRect();
            if (cursor) {
                const rect = cursor.getBoundingClientRect();
                let left = rect.left - outputRect.left + 15;
                let top = rect.top - outputRect.top - 5;
                left = Math.max(0, Math.min(left, outputRect.width - hand.offsetWidth));
                hand.style.left = left + 'px';
                hand.style.top = top + 'px';
            } else {
                const lastChild = output.lastChild;
                if (lastChild && lastChild.nodeType === Node.ELEMENT_NODE) {
                    const rect = lastChild.getBoundingClientRect();
                    let left = rect.right - outputRect.left + 15;
                    let top = rect.top - outputRect.top - 5;
                    left = Math.max(0, Math.min(left, outputRect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                } else {
                    const tempSpan = document.createElement('span');
                    tempSpan.style.display = 'inline-block';
                    tempSpan.style.width = '1px';
                    output.appendChild(tempSpan);
                    const rect = tempSpan.getBoundingClientRect();
                    let left = rect.left - outputRect.left + 15;
                    let top = rect.top - outputRect.top - 5;
                    left = Math.max(0, Math.min(left, outputRect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                    tempSpan.remove();
                }
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
