<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathenimation: Maths Equation Editor</title>
    <!-- MathJax Configuration (AsciiMath + LaTeX) -->
    <script>
        MathJax = {
            loader: {
                load: ['input/asciimath', 'input/tex', 'output/chtml']
            },
            asciimath: {
                delimiters: [['`', '`']]
            },
            tex: {
                inlineMath: [['$', '$']],
                processEscapes: true
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/startup.js" async></script>
    <!-- html2canvas for frame capture -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- gif.js for GIF export -->
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #1c2526;
            color: #e0e0e0;
        }
        h1, p, li {
            color: #e0e0e0;
        }
        #header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #header-row h1 {
            margin: 0;
        }
        #header-row .menu-buttons {
            display: flex;
            gap: 10px;
        }
        #header-row button,
        #controls-row button,
        dialog button {
            padding: 8px 12px;
            font-size: 16px;
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
            cursor: pointer;
        }
        #header-row button:hover,
        #controls-row button:hover,
        dialog button:hover {
            background-color: #5a5a5a;
        }
        #input {
            width: 100%;
            height: 100px;
            font-size: 18px;
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 10px;
            margin-top: 10px;
            box-sizing: border-box;
        }
        #output {
            font-size: 24px;
            position: relative;
            min-height: 200px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            max-width: 100%;
            box-sizing: border-box;
            background-color: lawngreen; /* lawngreen */
            color: #000000;            /* black text */
            border: 1px solid #aaa;
            padding: 10px;
            margin: 10px 0;
            overflow-x: auto;
        }
        #hand {
            position: absolute;
            font-size: 60px; /* enlarged */
            transform: rotate(45deg);
            transition: left 0.1s ease, top 0.1s ease, transform 0.5s ease, opacity 0.5s ease 0.5s;
            animation: float 2s ease-in-out infinite; /* smoother float */
            opacity: 1;
            color: #000000; /* black for visibility */
            pointer-events: none; /* don't block clicks */
        }
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(45deg); }
            50% { transform: translateY(-8px) rotate(45deg); } /* higher float */
        }
        #output.finished #hand {
            animation: none;
            transform: rotate(120deg) translate(60px, 60px);
            opacity: 0;
        }
        #cursor {
            display: inline-block;
            width: 8px;               /* thick cursor */
            height: 1.3em;
            background: #ff0000;      /* red */
            vertical-align: middle;
            animation: blink 1s step-end infinite; /* infinite blink */
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        dialog {
            width: 70vw;
            height: 70vh;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
            background-color: #2e2e2e;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
        }
        dialog button {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #4a4a4a;
            padding: 8px;
            text-align: left;
            color: #e0e0e0;
        }
        th {
            background-color: #3a3a3a;
        }
        #controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        #controls-row-left, #controls-row-right {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #controls-row select,
        #controls-row input[type="range"] {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
        }
        #speed-slider {
            width: 100px;
        }
        #controls {
            margin-top: 10px;
        }
        #symbols-table td {
            text-align: center;
            cursor: pointer;
            padding: 10px;
        }
        #symbols-table td:hover {
            background-color: #5a5a5a;
        }
        .rendering {
            background-color: #5a5a5a !important;
            cursor: not-allowed !important;
        }
        #resolution-container {
            text-align: right;
            margin: 5px 0;
            display: none;
        }
        #resolution-container select {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
            padding: 8px;
        }
    </style>
</head>
<body>
    <div id="header-row">
        <h1>Mathenimation</h1>
        <div class="menu-buttons">
            <button onclick="showDialog('examples')">Examples</button>
            <button onclick="showDialog('history')">History</button>
            <button onclick="showDialog('help')">Help</button>
            <button onclick="showDialog('symbols')">Symbols</button>
        </div>
    </div>
    <div id="controls-row">
        <div id="controls-row-left">
            <button id="play-pause-btn" onclick="playPauseAnimation()">‚ñ∂Ô∏è</button>
            <button onclick="stopAnimation()">‚èπÔ∏è</button>
            <label for="speed-slider">Speed:</label>
            <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
        </div>
        <div id="controls-row-right">
            <button onclick="undo()">‚Ü∫</button>
            <button onclick="redo()">‚Üª</button>
            <button onclick="clearOutput()">‚Ü©</button>
            <select id="download-format" onchange="updateResolutionOptions()">
                <optgroup label="--Image--">
                    <option value="png">Save as PNG</option>
                    <option value="jpg">Save as JPG</option>
                    <option value="webp">Save as WebP</option>
                </optgroup>
                <optgroup label="--Animation--">
                    <option value="gif">Save as GIF</option>
                    <option value="webm">Save as WebM</option>
                </optgroup>
            </select>
            <button id="download-btn" onclick="downloadOutput()">üì•</button>
        </div>
    </div>
    <div id="resolution-container">
        <select id="resolution-select">
            <option value="426x240">240p (426√ó240)</option>
            <option value="640x360">360p (640√ó360)</option>
            <option value="854x480">480p (854√ó480)</option>
            <option value="1280x720" selected>720p (1280√ó720)</option>
            <option value="1920x1080">1080p (1920√ó1080)</option>
        </select>
    </div>
    <div id="output"></div>
    <div id="controls">
        <textarea id="input" placeholder="e.g., f(x) = { -x if x < 0; 0 if x = 0; x if x > 0 }"></textarea>
        <div style="text-align: right; margin: 10px 0; display: flex; justify-content: flex-end; gap: 10px;">
            <button id="record-btn" onclick="toggleRecording()">‚è∫Ô∏è Record</button>
            <button id="start-btn" onclick="startAnimation()">Start Animation</button>
        </div>
    </div>
    <canvas id="captureCanvas" style="display: none;"></canvas>

    <!-- Dialogs -->
    <dialog id="examplesDialog">
        <h2>Mathematical Expression Examples</h2>
        <h3>Functional Expressions</h3>
        <ul>
            <li>Linear: ( f(x) = 2x + 3 )</li>
            <li>Quadratic: ( f(x) = x^2 + 2x + 1 )</li>
            <li>Piecewise (textbook style): ( f(x) = { -x if x < 0; 0 if x = 0; x if x > 0 } )</li>
        </ul>
        <h3>Trigonometric Expressions</h3>
        <ul><li>Basic: ( sin x + cos y )</li></ul>
        <h3>Calculus</h3>
        <ul><li>Limit: ( lim_(x->0) (sin x)/x = 1 )</li></ul>
        
        <h2>Examples</h2>
        <ul>
            <li>Monomial: 3x^2</li>
            <li>Binomial: x + 2y</li>
            <li>Trinomial: x^2 + 2x + 1</li>
            <li>Polynomial: x^3 + 2x^2 - x + 5</li>
            <li>Rational Expression: (x + 1)/(x - 2)</li>
            <li>Irrational Expression: ‚àö(x + 2)</li>
            <li>Radical Expression: root(3)(x^2 + 1)</li>
            <li>Square Root Expression: sqrt(x + 1) or ‚àö(x + 1)</li>
            <li>Exponential Expression: exp(x) or 2^x</li>
            <li>Logarithmic Expression: log(x) or log_2(x)</li>
            <li>Modulus (Absolute Value) Expression: |a| + |b| = |a + b|</li>
            <li>Modular Expression: x mod y = r ‚Üî x ‚â° r (mod y)</li>
            <li>Fraction: a/b</li>
            <li>Integral: int_0^1 x dx</li>
            <li>Union: A union B</li>
            <li>Matrix: [1,2;3,4]</li>
            <li>Limit: lim_(x->0) sin x / x</li>
            <li>Derivative: (d/dx) x^2</li>
            <li>Sum: sum_(k=1)^n k</li>
            <li>Product: prod_(k=1)^n k</li>
            <li>Vector: vec(a) = <<1,2,3>></li>
            <li>Binomial Coefficient: C(n,k) or binom(n)(k)</li>
            <li>Trigonometric Expression: sin x + cos y</li>
            <li>Inverse Trigonometric: arcsin(x)</li>
            <li>Trigonometric Identity: sin^2 x + cos^2 x = 1</li>
            <li>Compound Angle: sin(a + b) = sin a cos b + cos a sin b</li>
            <li>Multiple Angle: cos 2x = cos^2 x - sin^2 x</li>
            <li>Differential Expression: (d/dx) sin x = cos x</li>
            <li>Integral Expression: int_0^infty e^{-x} dx = 1</li>
            <li>Limit Expression: lim_(x->0) (sin x)/x = 1</li>
            <li>Series Expression: sum_(n=1)^infty 1/n^2 = pi^2/6</li>
            <li>Mean: bar x = (sum x_i)/n</li>
            <li>Variance: sigma^2 = (sum (x_i - bar x)^2)/n</li>
            <li>Probability: P(A union B) = P(A) + P(B) - P(A intersect B)</li>
            <li>Combinations: C(n,r) = (n!)/(r!(n-r)!)</li>
            <li>Permutations: P(n,r) = (n!)/(n-r)!</li>
            <li>Vector Expression: r = a i^ + b j^ + c k^</li>
            <li>Dot Product: (vec A dot B)</li>
            <li>Cross Product: (vec A cross B)</li>
            <li>Matrix Expression: A = [1,2,3;4,5,6]</li>
            <li>Determinant: det(A) or (det(A))</li>
            <li>Inverse Matrix: A^(-1)</li>
            <li>Complex Number Expression: z = a + b i</li>
            <li>Set Expression: A = {1,2,3}</li>
            <li>Membership: (x in A) or (x belong to A)</li>
            <li>Logical Expression: p ^^ q</li>
            <li>Quantified Expression: (for all) x in R, x^2 (greater than or equal) 0</li>
            <li>Parametric Expression: x = r cos theta, y = r sin theta</li>
            <li>Polar Expression: r = theta</li>
            <li>Tensor Expression: T_(i j)</li>
            <li>Functional Analysis Expression: ||f|| = sqrt(int |f(x)|^2 dx)</li>
            <li>Topology Expression: open set U</li>
            <li>Algebraic Structure Expression: group G</li>
            <li><strong>Piecewise Function:</strong> f(x) = { x, if x > 0; 0 if x = 0; -x, if x < 0 }</li>
        </ul>
        <button onclick="closeDialog('examples')">Close ‚ùå</button>
    </dialog>

    <dialog id="historyDialog">
        <h2>History</h2>
        <table><thead><tr><th>Title</th><th>Description</th><th>Date</th><th>Time</th></tr></thead><tbody id="historyBody"></tbody></table>
        <button onclick="closeDialog('history')">Close ‚ùå</button>
    </dialog>

    <dialog id="helpDialog">
        <h2>Help</h2>
        <p>Type math inside parentheses. For piecewise functions, use:</p>
        <code>( f(x) = { -x if x < 0; 0 if x = 0; x if x > 0 } )</code>
        <p>Click "‚è∫Ô∏è Record" before "Start Animation" to capture animation.</p>
        
    <h2>Help</h2>
        <p>For piecewise functions, use this natural syntax:</p>
        <pre>f(x) = { expr1, if cond1; expr2 if cond2; ... }</pre>
        <p>Examples:</p>
        <ul>
            <li><code>f(x) = { x, if x > 0; 0 if x = 0; -x, if x < 0 }</code></li>
            <li><code>|x| = { x, if x ‚â• 0; -x, if x < 0 }</code></li>
        </ul>
        <p>Here are some tips for using AsciiMath syntax to achieve textbook-style mathematical representations:</p>
        <ul>
            <li>For exponents/superscripts, use ^: e.g., x^2 renders as x¬≤.</li>
            <li>For subscripts, use _: e.g., x_1 renders as x‚ÇÅ.</li>
            <li>For fractions, use /: e.g., a/b or (x + 1)/(x - 2) renders as a over b.</li>
            <li>For square roots, use sqrt or ‚àö: e.g., sqrt(x + 1) or ‚àö(x + 1) renders as ‚àö(x + 1).</li>
            <li>For nth roots, use root(n): e.g., root(3)(x) renders as cube root of x.</li>
            <li>For logarithms, use log or log_b: e.g., log(x) or log_2(x).</li>
            <li>For exponentials, use exp or ^: e.g., exp(x) or 2^x.</li>
            <li>For modulus (absolute value), use abs or | |: e.g., abs(x) or |x| renders as |x|.</li>
            <li>For modular arithmetic, use mod or ‚â°: e.g., x mod y = r or x ‚â° r (mod y).</li>
            <li>For integrals, use int: e.g., int_a^b f(x) dx.</li>
            <li>For limits, use lim: e.g., lim_(x->a) f(x).</li>
            <li>For sums/products, use sum/prod: e.g., sum_(i=1)^n i.</li>
            <li>For matrices, use [ ; ]: e.g., [1,2;3,4] renders as a 2x2 matrix.</li>
            <li>For trigonometric functions, use sin, cos, tan, etc.: e.g., sin x.</li>
            <li>For inverse trigonometric, use arcsin, arccos, etc.: e.g., arcsin x.</li>
            <li>For hyperbolic functions, use sinh, cosh, etc.: e.g., sinh x.</li>
            <li>For derivatives, use (d/dx): e.g., (d/dx) x^2 = 2x.</li>
            <li>For integrals, use int: e.g., int x dx = x^2/2.</li>
            <li>For limits, use lim: e.g., lim_(x->infty) 1/x = 0.</li>
            <li>For series/sums, use sum: e.g., sum_(n=0)^infty x^n / n! = e^x.</li>
            <li>For mean, use bar or overline: e.g., bar x.</li>
            <li>For variance, use sigma^2: e.g., sigma^2 = (sum (x_i - bar x)^2)/n.</li>
            <li>For probability, use P(): e.g., P(A).</li>
            <li>For combinations, use C(n,r): e.g., C(n,r) = n! / (r!(n-r)!).</li>
            <li>For permutations, use P(n,r): e.g., P(n,r) = n! / (n-r)!.</li>
            <li>For vectors, use vec: e.g., vec a = a i^ + b j^ + c k^ renders with hats on i, j, k.</li>
            <li>For dot product, use dot: e.g., (vec A dot B) renders as \vec A ‚Ä¢ \vec B.</li>
            <li>For cross product, use cross: e.g., (vec A cross B) renders as \vec A √ó \vec B.</li>
            <li>For determinant, use det: e.g., det(A) or (det(A)) for |A|.</li>
            <li>For inverse matrix, use ^(-1): e.g., A^(-1).</li>
            <li>For complex numbers, use i: e.g., z = a + b i.</li>
            <li>For sets, use {}, in, union, intersect: e.g., A union B.</li>
            <li>For membership, use in or belong to: e.g., (x in A) or (x belong to A) renders as x ‚àà A; (x not in A) or (x does not belong to A) renders as x ‚àâ A. Without (), treated as text.</li>
            <li>For logical expressions, use ^^, vv, not, ->: e.g., p ^^ q.</li>
            <li>For quantified expressions, use for all: e.g., (for all) x in R renders as ‚àÄx ‚àà R. Without (), treated as text.</li>
            <li>For inequalities, use (greater than or equal), etc.: e.g., (greater than or equal) renders as ‚â•, (less than or equal) as ‚â§, (not equal) as ‚â†. Without (), treated as text.</li>
            <li>For parametric equations, group with commas: e.g., x = t^2, y = t^3.</li>
            <li>For polar coordinates, use r, theta: e.g., r = 1 - sin theta.</li>
            <li>For tensors, use subscripts: e.g., T_(i j k).</li>
            <li>For norms in functional analysis, use || ||: e.g., ||f||.</li>
            <li>For topology, describe in text with math: e.g., open set U.</li>
            <li>For algebraic structures, describe in text with math: e.g., group (G, *).</li>
            <li><strong>Piecewise Functions:</strong> Use { (expr1, cond1), (expr2, cond2) } syntax.</li>
            <li>Group with parentheses for complex expressions: e.g., (a + b)^2.</li>
            <li>Mix text and math: e.g., Modulus (Absolute Value) Expression: |a| + |b| = |a + b|.</li>
            <li>Math expressions are auto-detected; backticks are optional.</li>
        </ul>
        <button onclick="closeDialog('help')">Close ‚ùå</button>
    </dialog>

    <dialog id="symbolsDialog">
        <h2>Mathematical Symbols</h2>
        <p>Click a symbol to copy its AsciiMath code or character to the clipboard.</p>
        <table id="symbols-table">
            <tr><th>Symbol</th><th>AsciiMath Code</th><th>Description</th></tr>
            <tr><td>‚àà</td><td>in</td><td>Element of</td></tr>
            <tr><td>‚àÄ</td><td>forall</td><td>For all</td></tr>
            <tr><td>‚â•</td><td>>=</td><td>Greater than or equal to</td></tr>
            <tr><td>‚â§</td><td><=</td><td>Less than or equal to</td></tr>
            <tr><td>‚â†</td><td>!=</td><td>Not equal to</td></tr>
            <tr><td>‚àÇ</td><td>partial</td><td>Partial derivative</td></tr>
            <tr><td>‚àÉ</td><td>exists</td><td>There exists</td></tr>
            <tr><td>‚àá</td><td>grad</td><td>Gradient (nabla)</td></tr>
            <tr><td>‚àã</td><td>ni</td><td>Contains as member</td></tr>
            <tr><td>‚àè</td><td>prod</td><td>Product</td></tr>
            <tr><td>‚àô</td><td>cdot</td><td>Dot product</td></tr>
            <tr><td>‚àù</td><td>prop</td><td>Proportional to</td></tr>
            <tr><td>‚àû</td><td>infty</td><td>Infinity</td></tr>
            <tr><td>‚à™</td><td>union</td><td>Union</td></tr>
            <tr><td>‚à©</td><td>intersect</td><td>Intersection</td></tr>
            <tr><td>‚à®</td><td>vv</td><td>Logical OR</td></tr>
            <tr><td>‚àß</td><td>^^</td><td>Logical AND</td></tr>
            <tr><td>‚à†</td><td>angle</td><td>Angle</td></tr>
            <tr><td>‚à•</td><td>||</td><td>Parallel</td></tr>
            <tr><td>‚à´</td><td>int</td><td>Integral</td></tr>
            <tr><td>‚à¨</td><td>iint</td><td>Double integral</td></tr>
            <tr><td>‚àÆ</td><td>oint</td><td>Contour integral</td></tr>
            <tr><td>‚à¥</td><td>therefore</td><td>Therefore</td></tr>
            <tr><td>‚àµ</td><td>because</td><td>Because</td></tr>
            <tr><td>‚â™</td><td><<</td><td>Much less than</td></tr>
            <tr><td>‚â´</td><td>>></td><td>Much greater than</td></tr>
            <tr><td>‚äÇ</td><td>subset</td><td>Subset</td></tr>
            <tr><td>‚äÉ</td><td>supset</td><td>Superset</td></tr>
            <tr><td>‚äÜ</td><td>subseteq</td><td>Subset or equal to</td></tr>
            <tr><td>‚äá</td><td>supseteq</td><td>Superset or equal to</td></tr>
            <tr><td>‚äô</td><td>odot</td><td>Circle dot</td></tr>
            <tr><td>‚ä•</td><td>perp</td><td>Perpendicular</td></tr>
            <tr><td>¬π</td><td>^1</td><td>Superscript 1</td></tr>
            <tr><td>¬≤</td><td>^2</td><td>Superscript 2</td></tr>
            <tr><td>¬≥</td><td>^3</td><td>Superscript 3</td></tr>
            <tr><td>‚Å¥</td><td>^4</td><td>Superscript 4</td></tr>
            <tr><td>‚ÇÅ</td><td>_1</td><td>Subscript 1</td></tr>
            <tr><td>‚ÇÇ</td><td>_2</td><td>Subscript 2</td></tr>
            <tr><td>‚ÇÉ</td><td>_3</td><td>Subscript 3</td></tr>
            <tr><td>‚ÇÑ</td><td>_4</td><td>Subscript 4</td></tr>
            <tr><td>‚Åø</td><td>^n</td><td>Superscript n</td></tr>
            <tr><td>¬Ω</td><td>1/2</td><td>Fraction one-half</td></tr>
            <tr><td>‚Öì</td><td>1/3</td><td>Fraction one-third</td></tr>
            <tr><td>‚Öî</td><td>2/3</td><td>Fraction two-thirds</td></tr>
            <tr><td>¬º</td><td>1/4</td><td>Fraction one-quarter</td></tr>
            <tr><td>¬æ</td><td>3/4</td><td>Fraction three-quarters</td></tr>
            <tr><td>‚Öú</td><td>3/8</td><td>Fraction three-eighths</td></tr>
            <tr><td>‚Öù</td><td>5/8</td><td>Fraction five-eighths</td></tr>
            <tr><td>‚Öû</td><td>7/8</td><td>Fraction seven-eighths</td></tr>
            <tr><td>¬±</td><td>+-</td><td>Plus-minus</td></tr>
            <tr><td>Ôπô</td><td>(</td><td>Left parenthesis</td></tr>
            <tr><td>Ôπõ</td><td>{</td><td>Left brace</td></tr>
            <tr><td>Ôπú</td><td>}</td><td>Right brace</td></tr>
            <tr><td>Ôπû</td><td>)</td><td>Right parenthesis</td></tr>
            <tr><td>Ôπ§</td><td><</td><td>Less than</td></tr>
            <tr><td>Ôπ°</td><td>*</td><td>Asterisk (multiplication)</td></tr>
            <tr><td>Ôπ¢</td><td>+</td><td>Plus</td></tr>
            <tr><td>Ôπ¶</td><td>=</td><td>Equals</td></tr>
            <tr><td>Ôπ†</td><td>&</td><td>Ampersand (logical AND)</td></tr>
            <tr><td>Ôπü</td><td>#</td><td>Number sign</td></tr>
        </table>
        <button onclick="closeDialog('symbols')">Close ‚ùå</button>
    </dialog>

    <script>
        let entries = [];
        let currentOutput = '';
        let undoStack = [];
        let redoStack = [];
        let history = JSON.parse(localStorage.getItem('mathHistory')) || [];
        let isAnimating = false;
        let isPaused = false;
        let animationController = null;
        let isRecording = false;
        let recordedFrames = [];
        const FRAME_RATE = 10;
        let frameCaptureInterval = null;

        function toggleRecording() {
            const btn = document.getElementById('record-btn');
            if (isRecording) {
                isRecording = false;
                clearInterval(frameCaptureInterval);
                btn.textContent = '‚è∫Ô∏è Record';
                btn.style.backgroundColor = '#4a4a4a';
                // Keep recordedFrames for export
            } else {
                if (isAnimating) {
                    alert('Stop current animation before recording.');
                    return;
                }
                recordedFrames = []; // Clear old frames
                isRecording = true;
                btn.textContent = '‚èπÔ∏è Stop';
                btn.style.backgroundColor = '#c00';
            }
        }

        function updateResolutionOptions() {
            const format = document.getElementById('download-format').value;
            const container = document.getElementById('resolution-container');
            if (format === 'gif' || format === 'webm') {
                container.style.display = 'block';
            } else {
                container.style.display = 'none';
            }
        }

        function processMathContent(str) {
            if (!str.startsWith('(') || !str.endsWith(')')) {
                if (str === 'forall') return 'forall';
                str = str.replace(/\[([^\[]*?)\]/g, (match, p1) => '[[' + p1.replace(/;\s*/g, '],[') + ']]');
                str = str.replace(/C\(([\w+]+),\s*([\w+]+)\)/g, 'binom($1)($2)');
                str = str.replace(/P\(([\w+]+),\s*([\w+]+)\)/g, '^$1 P_$2');
                str = str.replace(/\(\s*det\((.+?)\)\s*\)/g, '|$1|');
                str = str.replace(/cross/g, 'xx');
                str = str.replace(/i\^/g, 'hat i');
                str = str.replace(/j\^/g, 'hat j');
                str = str.replace(/k\^/g, 'hat k');
                return str;
            }

            let inner = str.slice(1, -1).trim();
            const piecewiseRegex = /^(.*?=)?\s*{\s*([^}]+)\s*}$/;
            const match = inner.match(piecewiseRegex);

            if (match) {
                const prefix = (match[1] || '').trim();
                const body = match[2];
                const cases = body.split(';').map(c => c.trim()).filter(c => c);
                const latexCases = cases.map(c => {
                    let expr, cond;
                    if (c.includes(' if ')) {
                        [expr, cond] = c.split(/ if /, 2);
                    } else if (c.includes(',')) {
                        [expr, cond] = c.split(',', 2);
                    } else {
                        expr = c;
                        cond = '';
                    }
                    expr = expr.trim();
                    cond = cond ? cond.trim() : '';
                    if (cond) {
                        return `${expr} & \\text{if } ${cond}`;
                    } else {
                        return `${expr} &`;
                    }
                }).join(' \\\\ ');
                const latex = `${prefix} \\begin{cases} ${latexCases} \\end{cases}`;
                return `$${latex}$`;
            }

            const mathConversions = {
                'greater than or equal to': '>=',
                'less than or equal to': '<=',
                'greater than': '>',
                'less than': '<',
                'equal to': '=',
                'not equal to': '!=',
                'for all': 'forall',
                'there exists': 'exists',
                'x in y': 'x in y',
                'x not in y': 'x notin y',
                'subset of': 'subset',
                'superset of': 'supset'
            };
            return mathConversions[inner] || inner;
        }

        function detectMathExpressions(text) {
            const segments = [];
            let i = 0;
            const n = text.length;
            let current = '';
            let mode = 'text';
            let parenDepth = 0;

            while (i < n) {
                const char = text.charAt(i);
                if (mode === 'text') {
                    if (char === '(') {
                        if (current) {
                            segments.push({type: 'text', content: current});
                            current = '';
                        }
                        mode = 'math';
                        parenDepth = 1;
                        current = char;
                    } else {
                        current += char;
                    }
                    i++;
                } else {
                    current += char;
                    if (char === '(') {
                        parenDepth++;
                    } else if (char === ')') {
                        parenDepth--;
                        if (parenDepth === 0) {
                            mode = 'text';
                            segments.push({type: 'math', content: current});
                            current = '';
                        }
                    }
                    i++;
                }
            }
            if (current) segments.push({type: mode, content: current});
            return segments;
        }

        async function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            isPaused = false;
            animationController = { cancelled: false };
            const inputText = document.getElementById('input').value;
            if (!inputText) {
                isAnimating = false;
                return;
            }

            const segments = detectMathExpressions(inputText);
            const output = document.getElementById('output');
            const startBtn = document.getElementById('start-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            startBtn.disabled = true;
            playPauseBtn.textContent = '‚è∏Ô∏è';
            output.classList.remove('finished');
            output.innerHTML = currentOutput;

            const hand = document.createElement('span');
            hand.id = 'hand';
            hand.textContent = '‚úçÔ∏è';
            hand.style.opacity = '1';

            let currentText = currentOutput ? currentOutput + '<br>' : '';
            const baseCharDelay = 50;
            const baseWordDelay = 200;
            const speed = parseFloat(document.getElementById('speed-slider').value);
            const charDelay = baseCharDelay / speed;
            const wordDelay = baseWordDelay / speed;

            if (isRecording) {
                recordedFrames = [];
                clearInterval(frameCaptureInterval);
                frameCaptureInterval = setInterval(async () => {
                    if (!isAnimating) return;
                    try {
                        const canvas = await html2canvas(output, {
                            backgroundColor: 'lawngreen', // lawngreen
                            scale: 1
                        });
                        recordedFrames.push({ canvas });
                    } catch (e) {
                        console.warn('Frame capture failed', e);
                    }
                }, 1000 / FRAME_RATE);
            }

            for (let segment of segments) {
                if (animationController.cancelled) break;
                if (segment.type === 'text') {
                    const parts = segment.content.split(/(\s+)/).filter(p => p);
                    for (let part of parts) {
                        if (animationController.cancelled) break;
                        for (let char of part) {
                            if (isPaused || animationController.cancelled) {
                                while (isPaused && !animationController.cancelled) await delay(100);
                                if (animationController.cancelled) break;
                            }
                            currentText += char;
                            output.innerHTML = currentText + '<span id="cursor"></span>';
                            output.appendChild(hand);
                            await typesetMathJax();
                            updateHandPosition(hand);
                            await delay(charDelay);
                        }
                        await delay(wordDelay);
                    }
                } else {
                    if (animationController.cancelled) break;
                    const mathStart = currentText.length;
                    for (let char of segment.content) {
                        if (isPaused || animationController.cancelled) {
                            while (isPaused && !animationController.cancelled) await delay(100);
                            if (animationController.cancelled) break;
                        }
                        currentText += char;
                        output.innerHTML = currentText + '<span id="cursor"></span>';
                        output.appendChild(hand);
                        await typesetMathJax();
                        updateHandPosition(hand);
                        await delay(charDelay);
                    }
                    if (animationController.cancelled) break;
                    const processed = processMathContent(segment.content);

                    let mathOutput;
                    if (typeof processed === 'string' && processed.startsWith('$') && processed.endsWith('$')) {
                        mathOutput = processed;
                    } else {
                        mathOutput = '`' + processed + '`';
                    }

                    currentText = currentText.slice(0, mathStart) + mathOutput + currentText.slice(mathStart + segment.content.length);
                    output.innerHTML = currentText + '<span id="cursor"></span>';
                    await typesetMathJax();
                    updateHandPosition(hand);
                    await delay(200);
                }
            }

            if (!animationController.cancelled) {
                output.innerHTML = currentText;
                await typesetMathJax();
                output.appendChild(hand);
                updateHandPosition(hand);
                output.classList.add('finished');
                await delay(1000);
                hand.remove();

                entries.push(inputText);
                undoStack.push([...entries]);
                redoStack = [];
                history.push({
                    title: `Input ${history.length + 1}`,
                    description: inputText,
                    date: new Date().toLocaleDateString(),
                    time: new Date().toLocaleTimeString()
                });
                localStorage.setItem('mathHistory', JSON.stringify(history));
                currentOutput = entries.join('<br>');
            }

            startBtn.disabled = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            isAnimating = false;
            animationController = null;
            if (isRecording && frameCaptureInterval) {
                clearInterval(frameCaptureInterval);
            }
        }

        function playPauseAnimation() {
            if (!isAnimating) {
                startAnimation();
            } else {
                isPaused = !isPaused;
                document.getElementById('play-pause-btn').textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
            }
        }

        function stopAnimation() {
            if (!isAnimating) return;
            animationController.cancelled = true;
            isPaused = false;
            isAnimating = false;
            clearInterval(frameCaptureInterval);
            const output = document.getElementById('output');
            output.innerHTML = currentOutput;
            output.classList.remove('finished');
            const hand = document.querySelector('#hand');
            if (hand) hand.remove();
            document.getElementById('start-btn').disabled = false;
            document.getElementById('play-pause-btn').textContent = '‚ñ∂Ô∏è';
            typesetMathJax();
        }

        function undo() {
            if (undoStack.length) {
                redoStack.push([...entries]);
                entries = undoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function redo() {
            if (redoStack.length) {
                undoStack.push([...entries]);
                entries = redoStack.pop();
                currentOutput = entries.join('<br>');
                document.getElementById('output').innerHTML = currentOutput;
                typesetMathJax();
            }
        }

        function clearOutput() {
            entries = [];
            undoStack = [];
            redoStack = [];
            currentOutput = '';
            document.getElementById('output').innerHTML = '';
        }

        async function downloadOutput() {
            const format = document.getElementById('download-format').value;
            const container = document.getElementById('resolution-container');
            const resValue = container.style.display === 'none' 
                ? '1280x720' 
                : document.getElementById('resolution-select').value;
            const [w, h] = resValue.split('x').map(Number);
            const downloadBtn = document.getElementById('download-btn');

            // ‚úÖ Block video export if no recording
            if ((format === 'gif' || format === 'webm') && recordedFrames.length === 0) {
                alert('Please click "‚è∫Ô∏è Record" and run the animation first.');
                return;
            }

            if ((format === 'gif' || format === 'webm') && recordedFrames.length > 0) {
                downloadBtn.innerHTML = '.Rendering...';
                downloadBtn.disabled = true;
                downloadBtn.classList.add('rendering');

                try {
                    if (format === 'gif') {
                        await renderAndDownloadGIF(w, h);
                    } else if (format === 'webm') {
                        if (!MediaRecorder || !MediaRecorder.isTypeSupported('video/webm')) {
                            alert('WebM not supported in your browser. Try Chrome or GIF.');
                            return;
                        }
                        await renderAndDownloadWebM(w, h);
                    }
                } catch (err) {
                    console.error('Render failed:', err);
                    alert('Export failed. Try fewer frames or lower resolution.');
                } finally {
                    downloadBtn.innerHTML = 'üì•';
                    downloadBtn.disabled = false;
                    downloadBtn.classList.remove('rendering');
                }
            } else {
                await downloadImage(format, w, h);
            }
        }

        async function downloadImage(format, width, height) {
            const output = document.getElementById('output');
            try {
                const canvas = await html2canvas(output, { 
                    backgroundColor: '#7cfc00', // lawngreen
                    scale: 1 
                });
                const resized = resizeCanvas(canvas, width, height);
                let dataUrl;
                if (format === 'jpg') {
                    dataUrl = resized.toDataURL('image/jpeg', 0.9);
                } else {
                    dataUrl = resized.toDataURL('image/' + (format === 'webp' ? 'webp' : 'png'));
                }
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `math_output.${format}`;
                a.click();
            } catch (err) {
                alert('Image export failed.');
            }
        }

        function renderAndDownloadGIF(width, height) {
            return new Promise((resolve, reject) => {
                const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    width: width,
                    height: height,
                    repeat: 0,
                    transparent: '#lawngreen' // lawngreen
                });

                recordedFrames.forEach(({ canvas }) => {
                    const resized = resizeCanvas(canvas, width, height);
                    gif.addFrame(resized, { delay: 1000 / FRAME_RATE });
                });

                gif.on('finished', function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `math_animation_${Date.now()}.gif`;
                    a.click();
                    URL.revokeObjectURL(url);
                    resolve();
                });

                gif.on('error', reject);
                gif.render();
            });
        }

        async function renderAndDownloadWebM(width, height) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                const mimeType = MediaRecorder.isTypeSupported('video/webm; codecs=vp8')
                    ? 'video/webm; codecs=vp8'
                    : 'video/webm';

                const stream = canvas.captureStream(FRAME_RATE);
                const mediaRecorder = new MediaRecorder(stream, { mimeType });
                const chunks = [];

                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) chunks.push(e.data);
                };

                mediaRecorder.onerror = reject;

                mediaRecorder.onstop = () => {
                    if (chunks.length === 0) {
                        reject(new Error('No data'));
                        return;
                    }
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `math_animation_${Date.now()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                    resolve();
                };

                mediaRecorder.start();

                (async () => {
                    for (let i = 0; i < recordedFrames.length; i++) {
                        const frame = recordedFrames[i].canvas;
                        ctx.fillStyle = '#lawngreen'; // lawngreen
                        ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(frame, 0, 0, width, height);
                        await delay(1000 / FRAME_RATE);
                    }
                    setTimeout(() => mediaRecorder.stop(), 200);
                })();
            });
        }

        function resizeCanvas(src, width, height) {
            const temp = document.createElement('canvas');
            temp.width = width;
            temp.height = height;
            const ctx = temp.getContext('2d');
            ctx.fillStyle = '#lawngreen'; // lawngreen
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(src, 0, 0, width, height);
            return temp;
        }

        function showDialog(id) {
            document.getElementById(id + 'Dialog').showModal();
            if (id === 'history') populateHistory();
            else if (id === 'symbols') setupSymbolTable();
        }

        function closeDialog(id) {
            document.getElementById(id + 'Dialog').close();
        }

        function populateHistory() {
            const tbody = document.getElementById('historyBody');
            tbody.innerHTML = '';
            history.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${item.title}</td>
                    <td>${item.description}</td>
                    <td>${item.date}</td>
                    <td>${item.time}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function setupSymbolTable() {
            const rows = document.getElementById('symbols-table').getElementsByTagName('tr');
            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                cells[0].onclick = () => copyToClipboard(cells[0].textContent, 'Symbol');
                cells[1].onclick = () => copyToClipboard(cells[1].textContent, 'Code');
            }
        }

        function copyToClipboard(text, type) {
            navigator.clipboard.writeText(text).then(() => {
                alert(`${type} "${text}" copied!`);
            }).catch(err => console.error('Copy failed:', err));
        }

        async function typesetMathJax() {
            try {
                await MathJax.typesetPromise([document.getElementById('output')]);
            } catch (err) {
                console.error('MathJax error:', err);
            }
        }

        function updateHandPosition(hand) {
            const cursor = document.getElementById('cursor');
            const output = document.getElementById('output');
            const rect = output.getBoundingClientRect();
            if (cursor) {
                const cRect = cursor.getBoundingClientRect();
                let left = cRect.left - rect.left + 15; // adjusted for larger hand
                let top = cRect.top - rect.top - 5;
                left = Math.max(0, Math.min(left, rect.width - hand.offsetWidth));
                hand.style.left = left + 'px';
                hand.style.top = top + 'px';
            } else {
                const last = output.lastChild;
                if (last && last.nodeType === Node.ELEMENT_NODE) {
                    const lRect = last.getBoundingClientRect();
                    let left = lRect.right - rect.left + 15;
                    let top = lRect.top - rect.top - 5;
                    left = Math.max(0, Math.min(left, rect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                } else {
                    const span = document.createElement('span');
                    span.style.display = 'inline-block';
                    span.style.width = '1px';
                    output.appendChild(span);
                    const sRect = span.getBoundingClientRect();
                    let left = sRect.left - rect.left + 15;
                    let top = sRect.top - rect.top - 5;
                    left = Math.max(0, Math.min(left, rect.width - hand.offsetWidth));
                    hand.style.left = left + 'px';
                    hand.style.top = top + 'px';
                    span.remove();
                }
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
